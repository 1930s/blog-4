[{"id":"2016-03-11-elegant-mac-iterm2","title":"Mac优雅的工具集——iTerm2篇","contents":"\n\n本篇是我Mac优雅工具集系列下其中的一篇文章，[原文全文](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)托管在Gitbook上，分享了Mac系统下一些使工作变得更高效的工具。\n\n# iTerm2实用特性 Handy Features\n\n这里的参考：[https://www.iterm2.com/features.html](https://www.iterm2.com/features.html)\n\niTerm这个终端具有比系统默认终端更强的能力，而term3则是最近刚发布的beta版本。它比起系统默认终端具备更加丰富且实用的功能，比如：\n\n* 窗口切分(Split Panes)\n* 即时窗口(Hotkey Window)\n* 搜索，支持正则表达式\n* 全键盘复制(Mouseless Copy)\n* 自动补全(Auto Complete)\n* 粘贴版历史记录(Paste History)\n* 即时回放(Instant Replay)\n* 触发器(Triggers)(虽然还不知道是什么鬼)\n* ...等\n\n\n## 窗口切分 Split Panes\niterm2支持把窗口进行横向纵向切分，自己可以调整占据的比例，并且不活跃的窗口（inactive panel）还会变暗以强调活跃的窗口，对于需要一个工作区间做多件事的需求是很有用的。\n\n![iTerm2-panes-split](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-panes-split.png)\n\n* 纵向切分：`Command+D`\n* 横向切分：`Shift+Command+D`\n* 窗口切换：`Command+[` / `Command+]` / `Option+Command+Left` / `Option+Command+Right`\n\n\n## 即时窗口 Hotkey Window\nhotkey windows让你在任何地方都可以打开终端执行一些命令，对我来说应用最多的场合，应该是在搜索一些问题的时候，对于一些需要输入命令的解决方案可以即时拷贝命令，打开终端来输入。比如，现在我在搜索“如何安装zsh语法高亮的插件”，然后找到了zsh语法高亮插件的官方github，一共有三个步骤，我可以立即就打开iterm2的hotkey window，拷贝git clone的命令拷贝仓库，再打开一个窗口用vim修改`~/.zshrc`文件的内容，然后`source`一下，高亮搞定！\n\n![iTerms2-hotkey-window](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-hotkey-window.png)\n\n* 全屏切换：`Command+Enter`。全屏模式切换在hotkey window下尤其顺滑，太赞！！\n* 窗口模糊度toggle：`Command+U`\n\n\n## 搜索与全键盘复制粘贴 Search and Mouseless Selection\n这个功能其实我不太常用，就是可以在iterm2窗口中搜索内容，跟在编辑器中搜索一样，支持正则表达式搜索。此外，还支持选中当前搜索内容一键复制等，功能强大，就是没怎么用到。\n\n![iTerm2-search-and-mouseless-selection](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-search-and-mouseless-selection.png)\n\n* 搜索：`Command+F`\n* 复制选中内容：`Enter/Return`\n* 拓展选择（反向拓展）：`tab/Shift+tab`\n\n\n## 自动补全与粘贴板历史 Autocomplete and Paste History\n只要是在终端输入过的词或者命令，iterm2就可以帮你提供自动补全的建议，快捷键是`Command+;`，调出后即可通过纯键盘输入来筛选，比较适合快速输入一些长命令，如下，其快捷键也比`Control+R`友好一点，可视化程度更高一些。在其他相似的场景下，这个功能有一些替代品，比如目录导航时使用autojump/z、搜索历史命令时使用`Control+R`、`history`等。\n\n另外，iterm2也帮你保存了你粘贴过的命令，通过快捷键`Shift+Command+H`即可调出，但仅限于通过粘贴板的方式进入的命令。\n\n![iTerm2-autocomplete](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-autocomplete.png)\n\n![iTerm2-paste-history](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-paste-history.png)\n\n\n## 即时回放 Instant Replay\n逆天功能，可以回放过去任一**时刻**里iterm窗口的状态，在你需要之前窗口的一些信息时特别有用，可以回过去查看。虽然我不怎么用到这个功能，但你知道出事了随时都可以回去查看以前的信息。快捷键是`Option+Command+B`，每个session的即时回放缓存默认是4MB，可以在设置里面改。\n\n\n## 智能选择 Smart Selection\niterm2能够只能识别邮件地址、URL、文件名、文件夹等名称，按住`Command`键点击即可去到相应的地方。比较handy，用处不小也不大。\n\n\n## 系统配置\n\n### 要打开的选项\n\n* General -> Closing -> Confirm 'Quit iTerm2' command。`Command+Q`离`Command+W/1/2/3/Tab`如此之近，保不齐你什么时候手一滑按错所有窗口就都归西了\n* Appearance -> Window -> Hide scrollbars。据经验基本没必要，没用的元素就不打开让它占据空间\n* Profiles -> Text -> Cursor: Underline, Blinking cursor，光标指示符采用下划线并且加闪烁效果。个人喜好\n* Profiles -> Text -> Font: 12pt Monaco，此字体甚好\n\n### 要关闭的选项\n\n* General -> Selection -> Copy to pasteboard on selection。选中即复制，这不烦人嘛\n* General -> Window -> Adjust window when changing font size。比较建议关掉，虽然调整字体大小的时候不常见，但若窗口大小跟着变又得调窗口大小\n* Appearance -> Tabs -> Show tab close buttons。有`Command+W`和`exit`就行了\n* Keys -> Navigation Shortcuts -> To switch split panes，关掉\n* Keys -> Navigation Shortcuts -> To switch windows，关掉\n\n\n## 快捷键\n除了上面提到的在一些场景下比较常用的快捷键，这里尽可能地要精简整个软件所使用的快捷键，其他不常用的能删都删了。\n\n* `Shift+delete`，打开hotkey window，这里更改了默认的配置，因为空格的组合其他程序都在用，比如`Control+Space`是Intellij的上下文提示，`Command+Space`是Alfred/Spotlight的全局快捷键，`Option+Space`是系统默认的幻灯片播放，`Option+Command+Space`被我也因为前面快捷键被占的原因被我定制成输入法切换，`Shift+Space`是输入法的简繁体切换。太难记了，所以hotkey window的快捷键不这么用\n* `Control+A/E`，系统默认的快捷键，师承vim系风格，分别是跳到行头/行尾的快捷键，在编辑的时候对效率有一定帮助\n* `Command+Up/Down`，上一行/下一行\n* `Control+U`，直接删掉一行"},{"id":"2016-03-13-elegant-mac-oh-my-zsh","title":"Mac优雅的工具集——oh-my-zsh篇","contents":"\n\n本篇是我Mac优雅工具集系列下其中的一篇文章，[原文全文](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)托管在Gitbook上，分享了Mac系统下一些使工作变得更高效的工具。\n\n# oh-my-zsh\n\n有了一个趁手的终端，大的功能就算有了，接下来是一些小的细节的优化，比如主题，自动补全，三方插件集成等。因为[oh-my-zsh](http://ohmyz.sh/)太过有名，为我节省了一些选择的时间，也就不需要再考察其他选择，用了再说。其主页的介绍也是相当不低调，说用上一个主题，马上就会被别人当成极客中的大神，过来围观问你这个主题这么漂亮是怎么配的。然后深藏功与名的你，马上就会在程序员中作为神话被广泛传颂。\n\noh-my-zsh的两大主要功能分别是：\n\n* **主題（themes）**\n* **插件（plugins）**\n\n## 工作目录与配置文件\n[首先需要安装一个zsh](https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH)，安装方法在此不详述请点击链接或查看官网。安装时需要提前装好`git`、`wget`或`curl`工具。\n\nzsh默认的安装位置是在`~/.oh-my-zsh`文件夹下，同时在你的根目录`~`下会有一个配置文件`~/.zshrc`，这个配置文件非常重要，我们的主题和插件都是在这个文件里面配。同时它做好一些准备工作后，会去调用`~/.oh-my-zsh/oh-my-zsh.sh`文件设置好启动zsh所需的所有路径、加载完主题和插件。这个脚本源码值得阅读，官方文档中提到的许多特性都在这个脚本中体现，比如定制自己的配置、主题和插件等时的目录约定、定制主题优先于默认主题的加载、空/随机主题的配置和加载、自动更新等。配置好`~/.zshrc`文件后，`source ~/.zshrc`一下即生效。\n\n\n## 主题 Themes\n所有的主题都在`~/.zshrc`脚本的`ZSH_THEME`一行中配置，个人喜好是使用`\"random\"`值，每次zsh启动时都会随机加载一个主题。所有的官方标配主题都放在`~/.oh-my-zsh/themes`文件夹中，也可以[前往官方wiki之主题篇查看效果](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)。另外目前官方已不接受更多的主题提交请求，所以用户自己定制的一些主题则要前往[External Resource](https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes)查看。\n\n![zsh-random-themes](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-random-themes.png)\n\n![zsh-random-themes-fino-time](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-random-themes-fino-time.png)\n\n\n## 插件 Plugins\n就我所了解，zsh的插件并不提供实质性的功能，比如`git`插件，并不会自带git的命令行工具。插件提供的更多的是**集成**和**alias**的功能，只是为了让你在终端能更好更快地使用它。当然也有一些提供了便捷功能的插件，比如目录自动跳转等。\n\n插件开启在`~/.zshrc`文件的`plugins=(git ...)`一行配置，加入插件名并以空格分隔即可。所有的插件都已经放置在`~/.oh-my-zsh/plugins`目录下了。下面推荐一些个人比较推荐的插件，更多的插件可以在[github的官方wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview)查询。\n\n\n### 自动跳转 Fast Jumping \n* `autojump`。没有结果预览，不太友好\n* `z`。UI非常友好，并且有多个结果时支持使用TAB键进行导航特点是刚开始用要先进去你的目录让它“学习”\n* `wd`。可以给特定的目录“注册”（`wd add name`）别名，然后直接输入别名即可进入目录，特点是只能跳转到已注册的目录。但支持键盘操作，属于…可有可无的插件\n\n目前题主我三个工具都启用了，但打算关闭autojump，因为觉得z的UI更加友好\n\n![zsh-plugins-autojump](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-autojump.png)\n\n![zsh-plugins-z](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-z.png)\n\n![zsh-plugins-wd](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-wd.png)\n\n\n### 更简短的快捷键 Alias\n* `git`。首推git插件，它提供的是一个**全球统一**的alias，只要是使用zsh的终端都可以使用同样的缩略命令，常用的有比如`gst` `gca` `gca!` `gcan!` `gup` `gp` `gcb` `gcf` `gcm` `gco`等，完整的命令列表可以参考[zsh-git github的官方wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git)\n  ![zsh-plugins-git](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-git.png)\n* `sublime`。使用统一的`st`命令启动sublime，为你屏蔽了sublime可能混乱的安装位置\n* `history`。提供了`h`代替`history`，提供了`hsi`命令来搜索带特定字符串的历史\n\n\n### 自动补全、搜索与语法高亮\n* [git-completion](https://github.com/git/git/blob/master/contrib/completion/git-completion.zsh)。git命令的自动补全\n* [zsh-completion](https://github.com/zsh-users/zsh-completions)。zsh命令的自动补全\n* [zsh-syntax-highlighting](https://github.com/zsh-users/zsh-syntax-highlighting)。简直美妙\n* [zsh-history-substring-search](https://github.com/zsh-users/zsh-history-substring-search)。简直美妙，其实我看不太出来哪些补全是哪个插件做的，总之一口气全部装上就对了。zsh的语法高亮插件会在你命令输错的时候变红，下面是总的效果图\n\n![zsh-plugins-complete-overview](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-complete-overview.png)\n"},{"id":"2016-03-17-a-module-require-confusion","title":"说开去——项目的JavaScript模块化实践（上篇）","contents":"\n\n> 为保护商业机密，本博客中出现的所有代码与文字均已隐去所有与客户相关的信息。若仍有泄露请第一时间联系博主我：linesh.simpcity@gmail.com。\n\n## 原生JavaScirpt也自带了模块化支持？\n起因是这样的，今天发现项目上的每个js文件基本都是这样的写法：\n\n```javascript\nmodule(\"module.name.bainianlaodian\", (function() {\n   function isValidRequest() {\n      // implementation;\n   }\n   return {\n      isValidRequest: isValidRequest\n   }\n}()))\n```\n\n然后在外部引用的时候只需要使用`module.name.bainianlaodian.isValidRequest()`就可以调用模块内的函数了，而且可以引用任意路径下的js文件。我就有点好奇，什么时候JavaScript有模块了？一般都是通过[IIFE](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)和闭包结合的方式来人为地创建一个“模块”，但并未看过这种直接调用的写法。而且引用时的路径是在哪里指定的？虽然靠猜也可以大概猜到，这个只需要通过维护一个全局的map记录模块名和对应的函数即可做到，不过还是挺有兴趣看一下具体的实现。于是问了一下项目组的同事，大家也表示不太清楚这个`module`及用法。那就`Ctrl+B`一下，看一下`module`这个变量的定义点吧，Intellij给出的提示是：\n\n```\nmodule (externs.js, src/main/webapp/.../bower_components/xdate/build)\nmodule (colors.js, node_modules/grunt/node_modules/colors)\nmodule (cli.js, node_modules/grunt-contrib-jslint/node_modules/jslint/node_modules/cli)\nmodule Window (qunit.js, src/main/webapp/.../bower_components/modernizr/test/qunit)\nmodule Window (qunit.js, src/main/webapp/.../bower_components/underscore/test/vendor)\n...\n```\n\n看着都不像，而且都是通过`npm`或者`bower`引进来的工具。我所期待的结果，应该是类似于nodejs或者类似的框架或环境所提供的变量和加载方式，类似于[这篇文章](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000)讲到的模块加载的方式。嗯，既然蛮干无用，那就求助一下程序员的~~好基友~~良师益友Google吧：\n\n### Google也解决不到的问题\n\n* `javascript module`\n* `jquery module`\n* `javascript module(\"\", function() {`\n* `commonjs module`\n* `nodejs module`\n* `amd javascript module`\n* `es5 javascript module`\n* `es6 javascript module`\n\n用以上的方式作为关键词，均没有找到什么有价值的线索。nodejs中虽然存在`module`这么一个变量，但是项目中的这些js代码没有在服务端执行的可能。Google了一下也没有发现是jQuery或者CommonJS规范里的内容，es6中有模块的概念，但使用的是`import`的关键词。这下可没有线索了，我更加怀疑这个`module`是项目里自己定义实现的了。但是从定义处入手并不能找到有价值的线索，那怎么办呢？既然IDE也无法给出有效的提示，那我就做一下人肉搜索咯，`Ctrl+Shift+F`全文搜索一下`module`这个关键词！过了两秒钟，IDE弹出一个对话框说\"1,001 occurrences found so far. Are you sure you wish to continue?\"额的神啊，看来这个刨根问底还真不容易，不过既然这是唯一的线索了，那果断还是要Continue的。于是我拍下了Continue，一共有7455处地方出现了`module`这个词。茫茫词海中，该如何捞到有价值的线索呢……？\n\n### 谜底水落石出\n\n有意思。由于搜索的名字太过宽泛，所以必然有很多不相关的结果，应该选择性忽略。比如`pom.xml`、`build.gradle`、`npm-debug.log`、test/`node_modules`/`bower_components`/java代码文件夹下的一切东西，最后发现了两个挺有可能相关的文件，一个在`laodian-libraries.generated.js`文件中，另一个在`js/common`文件夹下的一个`module.js`文件里。前者一看就是生成的代码，代码如下：\n\n```javascript\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n```\n\n看起来好像有点关系，其实并没有。这段代码是在做运行环境的检测，若是underscore是运行在服务端，就把`_`注册到`module.exports`变量中作为模块暴露出去；若是运行在浏览器端，则把`_`注册到全局对象`root`中去。这个`root`在某处其实也是被赋予全局变量`window`的值的。同时，这个文件也确实是打包生成的，打包是由`Gruntfile.js`中配置的`concat` task来完成的。真是又增长了知识。\n\n好消息是，在`js/common/module.js`这个文件里，我们似乎找到了想要的答案：\n\n```js\n(function(global) {\n\n  global.module = function registerModule(moduleName, moduleContent) {\n    var root = global;\n\n    if (moduleName.indexOf('.') == -1) {\n      registerToContext(root, moduleName, moduleContent);\n    } else {\n      var contexts = _(moduleName.split('.'));\n      var context = contexts.initial().reduce(function(memo, current) {\n        if (!memo[current]) {\n          memo[current] = emptyModuleObject();\n        }\n        return memo[current];\n      }, root);\n      // 这段代码会返回倒数第二个子模块，并为模块树中还不存在的子模块创建一个空的对象\n      // 并注册到其父模块中。优雅简洁的函数式编程，mind-blasting... [\"Mind Blasting\"][1]\n\n      registerToContext(context, contexts.last(), moduleContent);\n    }\n  };\n\n  function registerToContext(parentContext, moduleName, moduleContent) {\n    // 这个注册机制决定了新定义的模块不能覆盖已有的同名模块，而会直接被丢弃\n    var module = parentContext[moduleName];   \n    if (!module) parentContext[moduleName] = moduleContent;\n  };\n})(this); // this === window\n```\n\n**这套自定义的模块加载机制，它会将模块名解析成一个有包含关系的模块树，然后将所有模块及其之间的关系“注册”（其实就是加）到全局的`window`对象中。所有js代码对“模块”的引用其实都是在直接引用全局对象`window`下的变量，因此也无需配置具体的路径。**\n\n看到这里，一开始关于“模块的注册和运行机制”的问题似乎就完全清楚了。在浏览器中实际调试了一把还发现，`laodian-libraries.generated.js`是在`module.js`之前运行的。但是这里我发现了一个细节：实际被发送到客户端的js文件并不叫`module.js`，而是叫`laodian-basic.js`。搜索了一下`module.js`，**竟没有被引用的地方！**这让我不仅又想探索一个问题：这个js究竟是在什么地方被include到页面上的？什么时候被include进来？发布前又被做了什么操作？作为一个基础设施型的js，应该是每个页面都需要的，那么项目上是采用什么方式来实现这个事情的？\n\n欲知后事，请听[下文](#/posts/2016-03-21-javascript-package-compress-template-and-reuse)分解。\n\n---\n\n[1]： [https://www.youtube.com/watch?v=vtKdNT7o858](https://www.youtube.com/watch?v=vtKdNT7o858)        \"Russell Peters: Mind-Blasting Joke\"\n"},{"id":"2016-03-21-javascript-package-compress-template-and-reuse","title":"说开去——项目的JavaScript模块化实践（下篇）","contents":"\n\n> 为保护商业机密，本博客中出现的所有代码与文字均已隐去所有与客户相关的信息。若仍有泄露请第一时间联系博主我：linesh.simpcity@gmail.com。\n\n## 再次出发\n\n在这个说开去系列的[上篇](#/posts/2016-03-17-a-module-require-confusion)中，我们已经回答了项目自带的模块化的实现，同时也带出了更多的问题，总结起来有以下这些。它们是本篇视图回答的问题：\n\n* `module.js`是如何被打包到`laodian-basic.js`中去？\n* 我们找到的这个js是在什么地方被include到页面上的？\n* 什么时候被include进来的？\n* 项目上用了什么方式来复用include这个js的那段代码？\n\n### 如何打包？\n上面我们还留下了一条线索：`laodian-basic.js`。既然`module.js`没有被引用的地方，那么就搜索下`laodian-basic.js`的引用点。这里我看到了两个引用点：\n\n1. ```jawr.js.bundle.laodian.id=/bundles/laodian-basic.js```\n2. ```<laodian:script bundle=\"/bundles/laodian-basic.js\" useVersionNumber=\"true\" />```\n\n看来似乎是配置了一些东西，然后直接在前端jsp(咦前端jsp怎么听起来怪怪的)通过`jsp tag`来引用。其中，第一个文件位于一个`jawr.properties`文件下，第二个文件的目录结构如下图所示。\n\n![brand-specific-jsp-directory-structure](http://7xqu8w.com1.z0.glb.clouddn.com/a82b64e24b984d2a92c0c39397481825.png)\n\n百年老店的项目有一个特点，就是支持多品牌，同一套代码需要服务不同地区的用户。我们挑了一个服务于大英地区的文件`british.jsp`，`Alt+F7`之，不能找到它的引用点。如我们第4点所要探索的问题所指出，由于要支持多品牌多页面，这个文件可能最终是通过这样的形式来被使用的：`<%@ include file=\"${brand}.jsp\" %>`（手动反射）。这个目前还没有太多线索，那么先看看第一条线索，Google一下[jawr](https://jawr.java.net/index.html)：它是一个可配置的、支持共用开发与发布代码的JS/CSS文件压缩与打包工具。配置简单：\n\n```java\njawr.js.budnle.laodian-basic.id=/bundle/laodian-basic.js\njawr.js.budnle.laodian-basic.child.names=laodian-pages\njawr.js.budnle.laodian-pages.mappings=/js/laodian-pages/**/*.js\n```\n\n看到上面这段代码就很清楚了，jawr会把`/js/laodian-pages/`文件夹下的所有js文件打包到`laodian-basic.js`文件中。JAWR其实还有一个`JawrServlet`，它会去读取`jawr.properties`(在`web.xml`文件的`init-param`配置`configLocation`)中的配置，并且拦截所有匹配`/js/*`的路径。\n\n\n### js是如何被引用到页面上的？——SiteMesh\n从上面搜搜到的这段代码已经可以看出，`laodian-basic.js`这个文件是在`british.jsp`中被引用的，后者引入了大量的CSS/JS/FAVICON等文件，似乎是一个入口文件，但它却没有再被其他文件引用：\n\n```html\n<head>\n  <script type=\"text/javascript\" src=\"laodian/common/js/laodian-libraries.generated.js\"></script>\n  <script type=\"text/javascript\" src=\"laodian/common/js/bootstrap.generated.js\"></script>\n  <home:script bundle=\"/bundles/laodian-basic.js\" useVersionNumber=\"true\" />\n\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"laodian/british/css/british-specific.less\" />\n</head>\n\n<body id=\"${activePage}\" class=\"${activePage}\">\n  <decorator:usePage id=\"specific-page\" />\n  <div class=\"page\">\n    <header class=\"Header\">...</header>\n    <main id=\"main-wrapper\">\n      <decorator:body />\n    </main>\n    <footer class=\"Footer\">...</footer>\n  </div>\n</body>\n```\n\n笔者眼尖，看到了`<decorator>`这个标签。它是SiteMesh框架定义的一个标签，sitemesh是一个分离页面内容和展现（presentation）的轻量级框架，其设计中运用了四人帮的装饰模式。Google Trends了一下它的热度，以及与它同类型的一些产品/框架的趋势，如下图，看起来似乎都要挂了。sitemesh3/tiles分别已经1/2年没维护了，只有wicket还在持续对Java8增加支持。这是不是意味着它所依附的模板技术也差不多日暮西山了？而模板技术又是前后端难以分离的一个重要的点，其实也从侧面印证了前后端分离的大趋势吧。\n\n![Trends-jsp-freemarker-etc](http://7xqu8w.com1.z0.glb.clouddn.com/f366e36a7e197a73e0b3cb46c563658d.png)\n\n![Trends-sitemesh-tiles-etc](http://7xqu8w.com1.z0.glb.clouddn.com/0b4e597eb0f1fba6eefa6c0d774e0961.png)\n\nAnyway不要跑题，火速看一下sitemesh的[文档](http://wiki.sitemesh.org/wiki/display/sitemesh/Setup+SiteMesh+in+5+Minutes+or+Less)，寻找启动项目的配置文件：`decorator.xml`！搜索一下项目的对应配置文件，果然有。看它的配置文件：\n\n```xml\n<decorators defaultdir=\"/WEB-INF/decorators\">\n  <decorator name=\"master-decorator\" page=\"main.jsp\">\n    <pattern>/british</pattern>\n    <pattern>/america</pattern>\n    <pattern>/...</pattern>\n  </decorator>\n</decorators>\n```\n\n这段代码在向我殷殷诉说：从特定路径下来的页面请求都会被`main.jsp`文件所前置装饰，再看到`main.jsp`文件：\n\n```java\n...\n<%\n  try {\n    String target = getLocale();\n    request.getRequestDispatcher(\"/WEB-INF/decorators/\" + target + \".jsp\")\n      .include(request, response);\n  } catch (...) {\n%>\n```\n\n这段代码也验证了我们一开始的判断，即我们是通过类似`${locale}.jsp`的形式来引用目标jsp文件的。至此所有实现都已经很清楚了：**通过SiteMesh对所有待渲染页面进行装饰，根据不同的地区分配到不同的`${locale}.jsp`模板去，后者再开始加载框架性（module模块化实现等）代码，最后渲染一般的html/js/jsp(template)。**\n\n## 总结与思考 Further Thinking\n\n许多时候一个项目的框架已经搭好，我们在使用的时候很少不会接触框架性的部分，比如js/css的压缩加载过程、多品牌的处理、框架选型等。既要写好业务代码，对于技术代码框架代码也要多了解，学会自己选型、搭脚手架。本文上篇讨论的其实是模块化的问题，下篇话题擦了模板技术的一点皮毛。深挖下去，还有许多问题可以了解：\n\n* 模块化的现状与实现。包括吕立青在[这里](http://blog.jimmylv.info/2016-03-10-getting-webpack-done-and-js-module-history)提到的一些相关技术或规范：CommonJS/AMD/WebPack/Browserify/NodeJS等\n* 模板技术。模板技术是依托于后端技术选型的，在选型的时候必须考虑现有的技术构架和迁移成本。另外在讨论模板技术孰优孰劣之前，也有必要先思考一下它所依托的后端框架的发展现状，比如Spring的生态圈（MVC/Boot)，比如是否必须要用Java来写后端代码等\n"},{"id":"2016-03-28-quick-coding-bibles","title":"唯快不破——快速编码实践","contents":"\n\n# 必先正名 —— 何谓快\n\n在谈论快之前，有必要先讨论一下何谓快。我的定义是，快不是速度快，而是效率高。当然许多场景下，速度快了效率自然就高。“效率高”又有两个延伸问题需要定义：\n\n* **做何事的效率？也即“快”的目标**，比如我要你2分钟洗5个梨，你说我洗10个苹果只需要1分钟，这种快跟目标不合就没用\n* **为何要高效率？**\n\n总结了一下半年多来的工作经验，我认为软件行业暂不讨论与人相关的因素下，技术工作需要具备三个能力：基础能力、快速构建能力、工程能力。这三项不在本文仔细展开，其中快速构建能力是指就一个项目需求或实际的工具需求，能使用已有知识和工具快速搭建出可工作的原型的能力。本文的快，（可能狭义地）认为是这种 快速适应项目或搭建应用 的快。\n\n为何要高效率。为节省出时间和脑力，以获得学习更多东西的机会。像挣更多钱这种大~~俗~~实话这里就不说了，好歹也是一枚文艺青年不是……【捂脸】\n\n# 快速编码笔记\n\n要在已有项目上完成添加或修改工作，不同的人可能有不同的方式。这里说说上了项目后学到的一点，即是采用 **直接定位修改点** 的方式。相比起了解整个系统的流程与工作原理，它更快，也更直接，是短平快的工作方式，有其学习的价值。对系统从头到尾的架构和细节了解，是课外的功夫，也有经验和积累，属于程序员的自我修养。因为我自己是~~处女座~~对原理更感兴趣的性格，在面对问题的时候会想先探究是如何实现的，有时就会阻碍学习或者解决问题的进度。这种不问为什么的理念，我觉得是个很好的补充。\n\n## 快速解决问题小笔记\n\n总结起来，在 **不问为什么，直接定位出错/修改地点** 的理念下，产生了一些直接但有效的实践，与我所见闻有很大关联，仅是学习笔记和抛砖引玉。这部分欢迎各种补充：linesh.simpcity@gmail.com。\n\n1. **看日志/控制台的输出信息，直接定位到问题发生的地点(controller, js, html element, etc...)**  \n  如果不知道日志的位置，可以观察项目的目录结构，或者跟踪Logger代码中的路径\n\n2. **GDT-Google Developer Tools的元素查看(Inspect elements)**  \n  可以通过id或class等特性有针对性地找到特定的元素，并借此搜寻作用于其上的绑定(比如jQuery、css等)\n\n3. **查看类或接口的所有实现(Command+Option+B in Intellij)**  \n  这里也是只能靠猜测的地方.但凡接口的实现必然有注入的地方，但在注入点到我们的调试点中间链可能很长，这样，只能通过找寻接口所有可能的实现，根据项目的实际情况，猜测_**注入发生的地点**_和_**被注入的实际类型**_，直接找到注入类，忽略中间过程。\n\n  **深入思考：**\n\n  接口提炼意味着所有可能被注入的对象存在着逻辑上（软件架构上，而非字面上）的联系。这里的实现，可能是指类或接口，也可能是字符串，其他类型的东西。实际的注入方式可能有以下几种：\n  * **字符串拼接**。这种情况说明待拼接串具有字面上的相似性（通常也反映了逻辑上的相似性），只是简单的文本填充。但其本身作为解耦的字串，可能暗示了其更高层使用者之间存在的逻辑联系。\n\n  * **反射**。我的毕设专题。它不同于手动声明对象的方式，它把“声明对象（包含为其申请内存，构建一个对象的过程）”这个动作从语言层面再次解耦出去。\n\n  * **混合使用**。其实这两种方式在Java中是以某种联系紧密连接的。字符串是反射特性使用的解耦符。它实现解耦的目的达到，在反射技术整个发展路上来看，这个技术的使用也是利大于弊的，但它也是有缺点的。抛开性能缺陷不说，它实现解耦的方式是把应用层的问题下放到语言层（虚拟机层），这样语言层面的代码可读性就消失了，你调试的难度就要增加。\n\n4. **spring mvc的RequestMapping注解找映射路径**\n\n5. **通过服务器(Tomcat, Jetty等)的配置文件找访问路径**  \n  只要路径不是自动生成，最终都是组织到配置文件来解决的节奏。\n\n6. **观察依赖管理工具的配置文件来看其引入的依赖**  \n  项目常用的管理工具有：\n  * 前端开发工具依赖管理npm(package.json)\n  * 前端开发库依赖管理bower(.bowerrc, bower.json)\n  * 前端任务构建管理grunt(gruntfile.js)\n  * 后端依赖管理maven(pom.xml)\n  * 后端任务构建管理gradle等。\n\n7. **CVS日志找某个特性的开发人**\n\n8. **Intellij的全文搜索**\n  全文搜索其实还是有一些技巧，根据前面采集到的一些有标志性的信息来进行搜索，今天看到子建还可以用`>Policy Holders<`这样的方式来搜索一个HTML标签等。多观察多学习。\n\n9. **网上资源库，一些可能有集中的相关context的人分享的平台，比如confluence**\n\n10. **前端UI/JavaScript相关可以在控制台Google Developer Tools中直接像素级调整/观察资源加载/调试等**\n  前端是个有趣且发挥想象力的地方，页面上的东西都是所见即所得，工作方式比较粗暴，要什么样式先直接在GDT里面调，像素级别地加减。\n\n## 慢即是快\n\n那么最后，与直接定位到问题所在的思维/解决方式不同的另外一种方式，是直接走通整个流程。这种方式通常更为可视化，理解更为透彻，也更花时间。但在尝试了所有能快速解决的方式仍不能成功的情况下，不能说这种方式就是慢。意在解决问题，而困难问题的解决，偏是需要耐心和智慧的。棋道术语曰“后中先”。常用的方法有：\n\n1. **经典的debug功能**\n\n2. **直接把整个程序跑起来**  \n  比如在做Java反射的时候，最为直观的方式就是把虚拟机build起来。\n\n## 查找一切 Google Everything \n好的，如果上面的方法依然不足以找到你需要的东西怎么办呢？把上面搜到的东西作为关键词，再采用其他的方式（如google）来进行链式搜索。Google乃是泛指，只要能搜到，管你是用什么工具（谢谢AlphaGo狗哥）。唯快不破，粗暴之美。\n\n## 总结与反省 Conclusion\n\n其实在快这个问题上，不妨认为“快”也只是其中的一种方式，不应拘束在术中，发现了好的方法能够提高效率，都该使用。另外，对为什么“快”的认知在学习的过程很重要，需要认清所需。不是一味追求快，以至对有时停步的思考都感到焦急。\n\n本篇侧重在技术的编码上，在其他方面还有很多习惯可以使我们的工作变得更快，比如：\n\n* 提高手速\n* 熟悉快捷键\n* 善用英文和搜索引擎\n* 使用markdown写作\n* 专注时间\n* 趁手的编辑器（sublime/vim/emacs等）/软件（Alfred/……没了）等\n\n对于工具这个专题，我 [自己也在写一些总结，托管在Gitbook上](https://www.gitbook.com/book/linesh/gitbook-elegant-mac-tools-system-closure/details)，尚未写完持续更新中，有兴趣的读者可以过来参阅。\n\n\n\n"},{"id":"2016-06-23-spring-mvc-documentation-reference","title":"Spring MVC官方文档翻译稿发布","contents":"\n\n这份翻译终于大概可以发布第一版可读的原型。几天在国内一些网站推广了一下，有点分散，于是决定在大本营这里放一份完整的发布稿，相当于是官方声明了，哈哈。既然是官方声明，那么官方这里倒是可以给点bouns，说说翻译过程的想法，以及最近一些情况。\n\n首先以下是发表在[OSC](http://my.oschina.net/u/1581831/blog/700769)/[CSDN](http://blog.csdn.net/codecleaner/article/details/51758452)/[Iteye](http://sodagreen-simplicity.iteye.com/admin/blogs/2307252)/[博客园](http://www.cnblogs.com/natasha-yarovenko/p/5616369.html)/[掘金](https://gold.xitu.io/entry/576e56962e958a00572bdb38/detail)/[v2ex](http://www.v2ex.com/t/288717#reply34)/[segmentfault](https://segmentfault.com/a/1190000005854194)/[Githuber](http://ask.githuber.cn/t/spring-mvc-4-2-4-release/1539/1)上的原文。\n\n\n> ![](http://7xqu8w.com1.z0.glb.clouddn.com/spring-logo.png)\n>\n> 前后经过九个月，我翻译的Spring MVC官方4.2.4版本中文文档可以发布第一个较为完整的版本了。译文上尽量做到准确并且符合中文习惯，让人能读懂，能理解。现全文发布如下，也希望它能够给出其价值，并收到反馈。\n>\n> * 七牛主站：[mvc.linesh.tw](http://mvc.linesh.tw)\n> * 备份镜像：[一个奇怪的域名](http://7xvpsh.com1.z0.glb.clouddn.com/)（主站不稳定时使用）\n> * [Gitbook原站](https://linesh.gitbooks.io/spring-mvc-documentation-linesh-translation/content/)（墙内访问较慢，且不太稳定）\n>\n> 阅读过程任何想法、建议、吐槽、强迫症~~不给译者狂点100个赞就浑身不舒服~~、觉得赞、觉得不赞，无论关于翻译、技术、样式等，请让我知道。你可以：\n>\n> * [来Github赞我~~被消费一个~~](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation)\n> * 在Gitbook讨论里[给我留言](https://www.gitbook.com/book/linesh/spring-mvc-documentation-linesh-translation/discussions)\n> * 在Github里给这个项目提[issue](https://github.com/linesh-simplicity/gitbook-translation-spring-mvc-documentation/issues)\n> * 在Github里给这个项目提[pull request](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation/pulls)\n> * [在文档上进行即时评论](http://mvc.linesh.tw)：在gitbook文档上，鼠标划过任何段落右侧，浮现`+`号时点击即可评论\n> * 邮箱：linesh.simpcity@gmail.com\n>\n> ![](http://7xqu8w.com1.z0.glb.clouddn.com/spring-mvc-documentation-translation-project-snapshot.png)\n>\n> ## 翻译过程，文本无关的思考\n>\n> 在翻译上仍在摸索，有自己的想法，体现到译本中，读者也许可以发现一些痕迹。这种种理念，如果要排个优先级，那么我觉得是：\n>\n> 1. 符合中文习惯。看起来像机翻不能要，名词乱翻误导读者不能要，长句复杂句太多不能要\n> 2. 准确传达原意。这点原本是最重要的，但让位于符合中文习惯，是因为如果译本有机翻痕迹，给人的品质感和可信度就降低了\n> 3. 更准确和更优雅的翻译风格。\n>\n> 软件开发的脚步一直在前进。发展尤其火和快的应数前端，各式样的MV*框架（Angular/React/Vue.js）、包管理（npm/bower）、构建工具（webpack/gulp/grunt）不胜其数，展示了前端所见即所得的强大魅力。与这股前后端分离趋势相适应的呢，后端也在提RESTful、MicroService这些东西。我对后端感兴趣，也希望能克服一些不舒适去学习前端的东西，一些UI实在使人愉悦。\n>\n> 另外呢，翻译和推广翻译又是两回事。翻译的时候自然希望译文受到大家喜欢和关注，但昨天在各大平台推广的时候呢，又发现什么样的题目和图片能更吸引读者眼球。后端在社群里相对前端确实没有那么可视化，很多模式、框架、架构等讨论起来流于文字，要是还不注重UI和representation的话，确实光看到题目就直接pass掉了。在活跃的社区呢，也看到了一些现象，大家现在想要看什么东西？\n>\n> * 从Android代码中来记忆23种设计模式\n> * 15款你可能不知道的精致Mac应用\n> * 100个弹框设计小结\n> * 5款高效的原型设计工具\n> * [Android名企面试题及涉及知识点整理](https://github.com/Mr-YangCheng/ForAndroidInterview)\n>\n> 资源太过丰富，导致我们学习浅尝辄止，这已经是一个许多人提过的问题。看到有人为我们总结了几点几点，一下就看完了，或者集合了什么资源，下意识点个赞，收藏一下（特别是还有这种[收藏插件](https://chrome.google.com/webstore/detail/better-bookmark/pniopfmciclllcpockpkgceikipiibol)），就完了。点赞收藏的成本很低，但这样确定不是在朝着抵抗力最低的路径在走吗？不是在放弃自己思考的权利么？难道不是在成为被平台消费的用户？看完了这些东西，我真的就提高了吗？\n>\n> 我反省的恰是这个。Bob Martin在《程序员的自我修养》一书中说，“那些在过去50年中来之不易的理念，绝大部分在今天仍像过去一样富有价值，甚至宝贵了”。在翻译的过程，我对MVC和Spring所提供的AOP、IOC、设计模式，以及Servlet 3.0规范一些东西，感觉有深挖的价值。里面是一些更为根本的代码功底和工程理念，非表层框架变迁所及。\n>\n> 推广之初，本是希望这个译本能被多多star，反省及此，又希望自己不要被消费，同时希望各位不要被我所消费。什么是有有益的，什么是自己需要的，什么工具能让自己更有效率，就去看，去用。其余形式应无所住。\n>\n> 以上。如此译本亦将脱离我而去。\n>\n> -- 2016年06月28日\n\n这个翻译项目从2015年9月份最早开始，中间停产了3个月，端端续续更新了1个月后，中间又停产了3个月左右，后来不知道为什么，又产生了坚持下去的偏执。所以最主要的部分都是半个月前翻出来的。这样的作息严格来说其实不太健康，不过最近一段时间在技术学习选择上出现了一点小迷惘，因此没事给自己找事情做，我觉得也无可厚非。而且，这个阶段并非全无价值。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/spring-mvc-documentation-contribution-traffic.png)\n\n入职11个月~~我真的没有在数日子~~，感觉上是进入了一个舒适区，项目、技术，和反馈。这个译本初稿的完成，其实也是我想对这段时间做个告别，重新出发。翻译项目会进入维护阶段，每天有一点规律的时间来维护。除此以外，在这个迷惘的过程中，似乎也渐渐对自己的定位有了一些思考，对想做什么，要做什么，也因此可能有了一些想法。\n\n~~以下内容纯属想太多~~\n\n逐渐发现，IT行业的工作里，我们所聊“技术”，其指向可能不同。尤其公司所需的技术与个人喜欢的技术有时并不重合，至少对我来说不甚重合。这其间关系与重叠自不赘述，但基本学习方向会分为企业级技术和个人技术来学。接下来主要的事情有：\n\n* **速度和基本功**。主要是规律、刻意地练习打字、快捷键、TDD、code kata。熊叔叔说的好，这些东西内化成下意识，才能更高效地思考其他\n* **professionalism**。项目上，作为一名ThoughtWorker的专业，要继续修炼\n* **企业级开发**。主要是想学习Java、Spring MVC/Boot、DevOps、Angular、React等构建稳定、可伸缩的企业系统的技术能力\n* **个人开发**。对于个人项目而言，最有用的莫非 **数据** 和 **展示** 两方面。因此，一些轻量级的语言工具会很有助益。这一块我想学有JavaScript、CSS（做展示）、脚本、Python（写爬虫）、CI（持续集成），以及一些提高效率的工具\n* **行业业务**。比如现在客户的业务，就可以刻意学习提高\n"},{"id":"2016-06-26-auto-deploy-translation-to-production-using-jenkins-and-qiniu","title":"我是如何进行Spring MVC文档翻译项目的环境搭建、项目管理及自动化构建工作的","contents":"\n\n> 感兴趣的同学可以关注这个[翻译项目](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation) 、 [我的博客原文](http://blog.linesh.tw/#/posts/2016-06-26-auto-deploy-translation-to-production-using-jenkins-and-qiniu) 和 [我的Github](https://github.com/linesh-simplicity)\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/spring-mvc-translation-project-final-representation.png \"Final website of MVC translation project\")\n\n前段时间翻译的Spring MVC官方文档完成了第一稿，相关的文章和仓库可以点击以下链接。这篇文章，主要是总结一下这个翻译项目自开始到上线发布，完整的一个生命流程。内容包括 **翻译环境搭建** 、**项目管理** 与 **自动化构建** 三部分。\n\n* [博客首页声明：Spring MVC官方文档翻译稿发布](http://blog.linesh.tw/#/posts/2016-06-23-spring-mvc-documentation-reference)\n* [托管在七牛上的翻译文档](http://mvc.linesh.tw)\n* [Github仓库](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation)\n\n## 环境搭建\n\n翻译与写作一样，首要之事均为专注于翻译/写作本身，而不考虑样式等方面。而章节之间的联系，自然也不想过多操心，这部分与样式一起，都可交由工具去处理。然后版本管理，不用说一定要上，后面也会看到github的生态圈使得它与其他工具做到了无缝集成。那么总结起来，我们需要的工具大体是：\n\n* markdown\n* markdown编辑器 Atom\n* 版本管理 Git\n* 代码托管平台 Github\n* 写书专用工具 Gitbook\n* HTML转markdown工具\n\n### Markdown\n\nMarkdown是一种近乎完美的写作标记语言，其最大的功劳便是将写作从内容中分离出来，这个分离使你只专注于写作内容本身，极大地提高了效率及工作愉悦度。没有markdown的话，会是怎样一种情况？想想HTML和写论文经常使用的word。你在HTML中为内容混入各种各样的样式，写论文时最痛苦的莫过于调样式（不过笔者当年写论文时通过Office Word的样式窗也是完美地解决了内容和格式的问题）。\n\n比如说，上面这段文字在markdown中写出来是这样的：\n\n```\n## 环境搭建\n\n翻译与写作一样，首要之事均为专注于翻译/写作本身，而不考虑样式等方面。而章节之间的联系，自然也不想过多操心，这部分与样式一起，都可交由工具去处理。然后版本管理，不用说一定要上，后面也会看到github的生态圈使得它与其他工具做到了无缝集成。那么总结起来，我们需要的工具大体是：\n\n* markdown\n* markdown编辑器 Atom\n* 版本管理 Git\n* 代码托管平台 Github\n* 写书专用工具 Gitbook\n* HTML转markdown工具\n```\n\n说起来markdown这个名字也有点意思，一般的标记语言叫markup language。这里将up改成down，寓意着将标记语言中与内容本身无关的标记全部剔除，形成一个精简子集。本篇不是markdown用法记，所以更多的语法请自行~~百度~~Google。我这里可以提供几个链接：\n\n* [Wikipedia: Markdown](https://en.wikipedia.org/wiki/Markdown)\n* [Markdown overview](https://daringfireball.net/projects/markdown/)\n* [Github上最有名的Markdown Cheat Sheet仓库](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)\n\n### Markdown编辑器 Atom\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/atom-as-translation-project-editor.png \"Use Atom as the translation project's editor\")\n\n编辑器的选择并无定式，打造一个完全符合自己操作习惯的编辑器也是每个程序员应做的一个工作，这里我不赘述。在Mac上，不错的markdown编辑器有Sublime 3、Atom、MacDown、Mark Editor、Gitbook Editor、Mou等，可挑选适合自己的，我选择的是Atom，是因为有一个刚性的需求它能够满足：\n\n* **与终端（terminal）的集成**。由于使用了版本管理，同时有时有拷贝文件、查看目录等需求，命令行肯定是必须随时在手的。终端方面我的选择是iTerm2+zsh，关于它们的配置和特性，可以查看博客的这两篇文章 [Mac优雅的工具集——iTerm2篇](http://blog.linesh.tw/#/posts/2016-03-11-elegant-mac-iterm2) 和 [Mac优雅的工具集——oh-my-zsh篇](http://blog.linesh.tw/#/posts/2016-03-13-elegant-mac-oh-my-zsh)。对如何在Mac上构建一个优雅的工具集有兴趣的同学，也可以前往Gitbook看看我正在写的这个系列：[关于优雅地使用Mac OS的理念、想法、工具与实践集](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)，不过还没写完就是了。\n\n### 版本管理 Git\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/git-logo.png \"Git Logo\")\n\nGit作为版本管理的意义也不赘言。你肯定不想自己的工作区最后变成这样：\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/word-as-version-manager.jpeg \"Word As version control will suck\")\n\n同样本小节也不是Git入门的命令集，这部分请自行查阅学习。当然我还是可以给出一些链接，虽然没有太多的意义~~我真的不知道为什么我还要给~~。基本的几个命令能熟悉就可以满足日常的需要了。另外，zsh下的Git可以配一下 快捷键(alias) 和 自动补全，具体配置非常简单，可以来这篇文章[Mac优雅的工具集——oh-my-zsh篇](http://blog.linesh.tw/#/posts/2016-03-13-elegant-mac-oh-my-zsh)看一下最终的效果。\n\n* [Git - 简易指南](http://www.bootcss.com/p/git-guide/)\n* [A Visual Git Reference](http://marklodato.github.io/visual-git-guide/index-en.html)\n* [廖雪峰的官方网站：史上最浅显易懂的Git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/)~~这浮夸的标题收视率果然好~~\n\n### 代码托管平台 Github\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/github-homepage.png \"Github Homepage\")\n\nGithub是 ~~世界上最大的同性交友平台~~ 目前最大 ~~我并无依据~~ 的代码托管平台，其生态圈之繁荣与力量令人震惊，几乎你需要的所有工具和资源都可以在上面找到。它与Git不是一个层级的概念 ~~`git=github.substring(0, 3)`~~ ，这部分请自行搜索。在这个平台上，我可以给翻译项目一个`README.md`文件，为阅读的人做简单的介绍以及引流，同时它可与CI（持续集成）、Gitbook等工具完美集成，其内置的issue、pull-request功能还能与Zenhub结合，直接当成trello来进行项目管理之用。相关的工具下一节会介绍。\n\n### 写书专用工具 Gitbook\n\n上文提到了翻译内容与样式的分离。实际上在这里样式这部分就是由Gitbook自带的渲染引擎来负责的。此外，Gitbook还能帮助你管理整个书的目录结构、章节生成、搜索、词汇表、站点构建与生成等，同时它也有丰富的插件生态。这一切只需要你进行少量的配置（其实，就只是在书的根目录下运行`gitbook init`命令，它会生成下图所示的一个目录结构），其低学习成本与高效益，使它成为了写书最易入门的趁手工具。\n\n```\n.\n├── README.md\n└── SUMMARY.md\n```\n\n## 项目管理\n\n项目管理方面的需求，主要是有时会有想法出现，希望增加什么特性，或者想到什么问题不想马上修，那么最好是有一个TODOLIST可以随时记录下来，并且能被方便地检索到。这方面的需求，怎么解决呢？\n\n### issue + zenhub\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/zenhub-as-issue-tracker.png \"Use Zenhub As Issue tracker\")\n\nGithub内置的issue功能已经好用到爆，再加上专为Github issue功能定制的[Zenhub](https://www.zenhub.com/)简直就是活生生把issue当成trello来用。一些内置特性如下，稍加体验即可满足所有小型项目管理上的需求：\n\n* issue可以通过commit sha直接与相关的单次提交关联，还可以 [通过提交信息来引用、关闭issue](https://help.github.com/articles/closing-issues-via-commit-messages/)\n* issue中支持GFM(Github Flavored Markdown)，可以直接使用todolist的语法\n* 通过Command/Ctrl+V可以直接在留言中上传截图\n* 可以为issue添加标签（tag）、类别（pipeline, 如正在做、还没做、已完成等）\n* 可以为issue估点、指定负责人、燃尽图，简直就是为敏捷实践而生，不过在这个翻译项目中用不到这些，毕竟自己给自己估点没什么意思\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/github-flavored-markdown-todolist.png \"Github flavored markdown todolist\")\n\n## 自动化构建\n\n自动化什么的构建？这还要从本翻译稿的托管平台——Gitbook——说起。gitbook是一个绝好的写作平台，官方也通过Webhooks提供了与Github的集成，只要你把代码`git push`到远端仓库，Gitbook就会自动拉取仓库中的内容，按照特定的格式为书本构建站点。过大概2到3分钟，你就可以在[Gitbook](https://linesh.gitbooks.io/spring-mvc-documentation-linesh-translation/content/)上看到自己最新的更新已经到书上了。一切看起来都十分美好，一键提交与部署。但是有一个最大的问题：**Gitbook在国内的速度不行，轻则卡顿，重则整站被墙刷不出页面**。\n\n这种情况下，我决定将整个翻译同时迁移到七牛上。七牛的CDN在国内速度名声在外，用来托管静态站点再好不过~~只需要拍两张身份证正反双面的照片上传等待审核即可~~。迁移也很简单，因为gitbook生成的静态站点其实就是`_book`文件夹，只需要把这个文件夹下的全部东西放到七牛空间上去，在使用`index.html`作为入口就可以了。但是，问题又来了：\n\n* 七牛网站上无法上传文件夹。就算可以，我也无法忍受每次都要手动将文件夹拖上去\n* 每次仓库有更新，都需要将最新的内容同步到七牛空间上，并覆盖旧版本的同名文件\n* 第二步的操作还不能通过githook+shell的方式来做，因为整个过程的耗时会使`git push`的反馈周期变长，从而使得我更不倾向于频繁提交，影响翻译体验\n\n解决方案也很简单：\n\n* 第一条，寻找七牛的[SDK](http://developer.qiniu.com/resource/official.html#tool)，通过命令行进行上传\n* 第二条，既然不能，[细想]也没必要在本地做，那么就在远端做好了。远端在哪里呢？ **CI/Pipeline** 啊，这样构建站点、同步文件等工作都可以并行进行了，既不会阻碍本地开发速度，也不是翻译时需要考虑的问题，我还是只需要像以前一样`git push`提交代码即可，站点从构建到最终上线，都有CI在负责\n\n想法出来了，在实施的时候还是走了一些弯路的。这些折腾过程在此无法深表，只有可能带过~~程序员们都懂的~~。在CI的选择上，我选择了Jenkins 2.0，原因比较纯粹，最近项目上在使用Jenkins 2.0，我刚好当是练手。至此文章成笔之时，我仍在考察其他选择，比如travis-ci，看起来UI和配置都简单许多，这部分可能是后文了。下面会简单介绍~~折腾~~搭建Jenkins 2.0作为本翻译项目CI的步骤和关键节点。\n\n### Jenkins下载、安装与启动\n\n话说Jenkins不愧为CI/CD领域的先锋，这个产品每周都会发一个小版本（目前最新是2.11）。Jenkins 2.0的安装，可以通过直接下载安装包的方式下载，在Mac上也可以通过`brew install jenkins`来下载安装。安装完成后，运行`jenkins`即可在`localhost:8080`启动一个本地的jenkins。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/jenkins-pipeline-home-page.png \"Jenkins home page\")\n\n### 注册一个七牛开发者账号\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/qiniu-home-page.png \"Qiniu Home Page\")\n\n流程十分简单，免费用户可以有一个空间，有一定的流量限制，不过通常来说对于只有一个空间需求的用户来说，这样的流量应该不会超吧。由于我已经超过了一个空间的需求，同时我又有配置独立域名的需求，所以需要更多的权限。流程也很简单，进行实名认证、填写身份证、上传本人及身份证正反面照片各一张~~本人不需拍反面~~，最后保证账户里有最少10元即可。\n\n### Jenkins：新建一个类型为pipeline的项目\n\npipeline搭建起来了，接下来我们需要捋一捋前面说到的两个步骤：构建站点、上传站点文件到七牛空间。细分下来，主要是有以下的task要做：\n\n* 引入必要的依赖\n* 构建站点\n* 同步到七牛\n\n#### 使用NPM，引入gitbook/gitbook-cli/qiniu\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/npm-home-page.png \"Npm home page\")\n\n我们想要构建站点，必然使用gitbook的命令行工具；要使用七牛的命令行，也必然引入相应的工具。这里我走过一些弯路，比如尝试将七牛工具以插件形式引入到Jenkins job中来，但是2.0以后，我们更倾向于使用脚本来描述构建工作，而非将Jenkins单纯当作一个转存/转储的工作区间并为该workspace零散地写一些适配脚本。因此，在pipeline类型的项目就不存在每个job特定的配置空间，若想使用插件，配置起来有些麻烦。于是，最后我决定使用七牛的npm包（肯定是有的），并通过NPM来管理所有依赖。以下是一个`package.json`文件需引入的依赖：\n\n```json\n{\n   ...\n   \"devDependencies\": {\n        \"gitbook\": \"^3.1.1\",\n        \"gitbook-cli\": \"^2.3.0\",\n        \"qiniu\": \"^6.1.11\"\n    },\n    ...\n}\n```\n\n另外，需要注意的是，Gitbook的渲染引擎已经升级到v3.1.1版本，与Legacy v2.6.7版引擎相比，主要的区别是[v3支持多个部分(part)的文章](https://github.com/GitbookIO/gitbook/blob/master/docs/pages.md)、默认关闭了目录中章节前的数字等。其中multipart的部分有些[小bug](https://github.com/GitbookIO/gitbook/issues/1301)但还可以忍受，但是默认关闭的目录数字则需要通过以下的配置给设置回来。在`book.json`文件中：\n\n```json\n{\n   \"gitbook\": \">=3.1.0\",\n   \"pluginsConfig\": {\n      \"theme-default\": {\n         \"showLevel\": true\n      }\n   }\n}\n```\n\n#### 构建站点\n\n简单地运行命令`gitbook build`即可生成站点目录。最后的构建脚本[Jenkinsfile.groovy](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation/blob/master/Jenkinsfile.groovy)如下所示：\n\n```groovy\nnode ('main') {\n    stage 'Pull latest changes from SCM'\n    git([\n        url: 'git@github.com:linesh-simplicity/translation-spring-mvc-4-documentation.git',\n        branch: 'master'\n    ])\n\n    stage 'Download dependencies: Gitbook/Gitbook-cli/Qiniu'\n    sh 'npm install'\n\n    stage 'Build book serving directory through Gitbook'\n    sh 'gitbook build --gitbook=3.1.1'\n\n    stage 'Upload production _book to Qiniu through their API'\n    sh './jenkins/sync-book-to-qiniu.sh'\n}\n```\n\n#### 上传文件到七牛\n\n使用七牛的命令行工具进行文件上传，需要配置一些东西，主要是要同步的本地目录、七牛的Access key和Secret Key等，示例代码则可以从七牛SDK的官网上参考。我最后完成的这份同步脚本[sync-book-to-qiniu.js](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation/blob/master/jenkins/sync-book-to-qiniu.js)如下所示，其中完成了 **准备本地同步目录** 、 **排除不同步文件** 、 **指定覆盖上传策略** 等工作：\n\n```js\nconst qiniu  = require(\"qiniu\");\nconst glob   = require('glob');\nconst crypto = require('crypto-js')\n\nconst ignoredFiles = [\n    'Jenkinsfile.groovy',\n    'sync-book-to-qiniu.js',\n    'sync-book-to-qiniu.sh',\n    'mvc-origin.md',\n    'package.json'\n];\n\n// node ./jenkins/sync-book-to-qiniu.js $ACCESS_KEY $SECRET_KEY\nconst qiniuAccessKey = process.argv.slice(2, 3);\nconst qiniuSecretKey = process.argv.slice(3);\n\n// Prepare Qiniu configuration options\nqiniu.conf.ACCESS_KEY = qiniuAccessKey.toString(crypto.enc.Utf8);\nqiniu.conf.SECRET_KEY = qiniuSecretKey.toString(crypto.enc.Utf8);\nconst bucket = 'mvc-linesh-tw';\n\nglob.sync('_book/**/*.*', {}).filter(filename => {\n    for (let ignored of ignoredFiles) {\n        if (filename.endsWith(ignored)) return false;\n    }\n    return true;\n}).forEach(filepath => {\n    const resource_key_in_qiniu_api = filepath.substring('_book/'.length, filepath.length);\n    // ':' means allow override upload. For further details refer to offical API docs\n    const policyToken = new qiniu.rs.PutPolicy(bucket + \":\" + resource_key_in_qiniu_api).token();\n    uploadFile(policyToken, resource_key_in_qiniu_api, filepath)\n})\n\nfunction uploadFile(uptoken, key, localFile) {\n    let extra = new qiniu.io.PutExtra();\n    qiniu.io.putFile(uptoken, key, localFile, extra, function(error, response) {\n        if(!error) {\n            console.log('[Success] File uploaded: ' + response.key);\n        } else {\n            console.log(error);\n        }\n    });\n}\n```\n\n同行们求review代码啊～\n\n### 避免提交七牛的AK和SK\n\nAK(Access Key)和SK(Secret Key)是七牛分配给注册开发者的一对密钥，不能泄露，否则其他人得到了就可以对你的七牛空间进行任意操作。但是，你要把构建工作自动化，就必须这段脚本提交到github上，同时CI还要能从你的代码中读出正确的AK和SK，这要如何做到呢？回答是，通过CI提供的接口，由pipeline将参数注入到你的代码中。这样，AK和SK就被保存在了pipeline上，别人无权对其进行访问。在Jenkins CI上，这是通过一个[EnvInject插件](https://wiki.jenkins-ci.org/display/JENKINS/EnvInject+Plugin)来做到的，在travis-ci中则更加简单，直接设置。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/jenkins-envinject-plugin.png \"Jenkins EnvInject Plugin\")\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/travis-ci-env-setting.png \"Travis CI environment variables settings\")\n\n### 使用travis-ci进行自动化构建\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/travis-home-page.png \"Travis home page\")\n\n——本小节为2016-07-06日添加\n\n如今我已经把本项目的构建从Jenkins迁移到travis-ci上去了，原因是travis-ci是一个online的CI，界面更漂亮，配置也更为容易。在构建步骤上，与通过Jenkins的构建大同小异：\n\n* 设置好必要的环境（node.js, npm等，因为Jenkins是在本地跑，不存在这些问题，travis上需要小配，也非常简单）\n* 通过npm安装必要的依赖（qiniu，gitbook等，也简单，跑一下安装即可）\n* 通过gitbook将站点目录构建出来\n* 配置好加密的AK/SK，并在构建脚本中获取\n* 将构建目录上传到七牛\n\n大部分步骤与使用Jenkins时并无二样。与Jenkins的JOB模型不同的是，travis整个核心的构建阶段只有两个：`install`和`script`，即安装依赖和执行脚本。每个阶段都有前后的拦截点，你可以在前后做些必要的操作。此外，对于依赖安装，travis还提供了缓存的功能。只需要在项目下放置一个`.travis.yml`文件即可触发整个构建。这个脚本的核心部分大致如下，没有中文注释，代码自注释：\n\n```\nlanguage: node_js\nnode_js:\n    - '6.1'\ncache:\n    directories:\n        - node_modules\nbefore_install:\n    - npm install -g gitbook-cli\ninstall:\n    - npm install\nscript:\n    - gitbook build\n    - ./travis/sync-book-to-qiniu.sh\n```\n\n另一个问题是AK和SK的问题，在Jenkins的方式是通过环境变量(env variables)的方式注入。不过现在travis不在本地，不敢这么玩了，虽然travis也提供了环境变量的注入，但毕竟把AK/SK上传到travis的服务器上了。好在travis提供了加密API，即你可以在本地先加密你的AK/SK，然后将这个加密后的值上传到配置文件中。travis执行构建的时候自动帮你解密回来，同时其他人也无法看到你的敏感数据。具体命令如下：\n\n```\ntravis encrypt \"ACCESS_KEY=value_without_bash_escape_characters\" --add\ntravis encrypt \"SECRET_KEY=if_there_is_special_characters_you_need_to_escape_them\" --add\n```\n\n## 总结\n\n![](http://7xvpsh.com1.z0.glb.clouddn.com/running-jenkins-pipeline.png \"Running jenkins pipeline\")\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/travis-upload-final-success-view.png \"Travis final success view\")\n\n呼呼，最后看到这个图的时候还是很激动的，所有的部署工作都成功了。那么也是时候结束了，本篇文章总结起来，讲了三方面的内容：\n\n* 如何准备和搭建让翻译工作更加专注和高效的环境和工具，如markdown/atom/gitbook/git/github等\n* 如何使用github的issue和zenhub来辅助管理翻译项目中的待办事项和协作\n* 如何使用CI工具Jenkins/travis将整个站点的构建和发布自动化，提高翻译和部署效率\n\n\n—— 2016-07-01\n\n## Bonus：Marketing\n\n哎呀bonus，其实说不清是彩蛋还是坏蛋了，主要是聊聊文章和推广吧。一开始推广的时候是地毯式地发，与吕靖所发平台有略微不同。发的平台有 [OSC](http://my.oschina.net/lineshtw/blog/704441) / [CSDN](http://blog.csdn.net/codecleaner/article/details/51808331) / [Iteye](http://sodagreen-simplicity.iteye.com/admin/blogs/2308678) / [博客园](http://www.cnblogs.com/natasha-yarovenko/p/5634661.html) / [掘金](https://gold.xitu.io/entry/5777f8395bbb50005948d9bb/detail) / [v2ex](http://www.v2ex.com/t/289735) / [segmentfault](https://segmentfault.com/a/1190000005858229) / [Githuber](http://ask.githuber.cn/t/spring-mvc/1547)一共8个地方，再后来便对此事有所厌倦，感觉短短两天让我的状态一直是在坐等点赞，真是需要戒断的欲望。\n\n不过，还是从各个平台的推广当中初步学习到推广的一些细节和方法论，以便日后推广时有的放矢，节约精力。方法论总结起来，有4点；小细节总结起来，有其他3点。\n\n### 方法论\n\n* **流量分析**。通过数据可以拿到不同平台带来的流量差别，从而不同平台可以有不同的推广力度，合理分配资源\n* **用户质量与数据**。视文章内容不同、平台偏好题材不同、平台主流用户不同，推广带来的效果也不同。所谓“效果”，可以浏览数、浏览时间、点赞数、评论数、相关链接点击数等数据来衡量\n* **自动化发布**。第一点中提到的平台差异，其实有一点伪命题。如果能拿到各个平台发布、修改文章的API，再通过自动化的方式一键发布、推广到各个平台，则人力成本可以忽略不计\n* **马太效应**。仓库越多人点赞，点赞的人质量越高，说明越靠谱，用户点赞的阻力也越小\n\n方法论利于用户分析，但不要走投机取巧的路子（但知道了至少想投的时候能投投）。专注于自我提升与内容质量本身，而非其他厚薄。在方法论方面，phodal有一些文章可供参考\n\n* [如何提高影响力](https://www.phodal.com/blog/how-to-improve-impact/)\n* [程序员如何提高影响力2.0](https://www.phodal.com/blog/improve-impact-2/)\n* [什么样的文章受欢迎](https://github.com/phodal/beautiful-content/blob/gh-pages/chapters/chapter1.md)\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/my-marketing-platforms-and-bandwidth.png)\n\n从上图看，主要的流量还是来自掘金和v2ex，掘金的流量是直接导到七牛的主站。至于用户质量、有效的目标群体等仍无法知晓，但至少是一个推广的好去处。\n\n就编辑体验来讲，OSCHINA/CSDN两个平台支持markdown编辑~~哪个平台不支持markdown~~，前者还能自动生成目录，界面进行过改版，比以前有较大提升，但细看还是丑。从流量上看，OSCHINA贡献了一小块流量~~OSC上给人浓浓的圈子感我就不说了~~，CSDN则似乎不能帮忙推荐首页，文章发了两天，浏览量还是一位数。对于尚未建立平台和品牌的个人程序员来说，要获取流量似乎比较困难。\n\niteye和博客园，两个网站都不支持用markdown编辑，要先在其他地方用markdown here转一次再copy过来，遑论其他手动编辑方法的效率。iteye的流量大概是OSChina的三倍左右，三小丢丢；博客园发布了两天，浏览量一位数以内。\n\nsegmentfault是我用过样式最好的网站，有目录，markdown渲染样式稳重不浮夸，可惜流量也不多。还有其他一些推广网站，比如githuber/百度知道等，流量都非常小。\n\n### 小细节\n\n* **吸引人的题目**。资讯辣么多，你平时浏览会怎么办？是不是先看题目抓不抓人，筛选出有兴趣的文章？除了被消费，我们似乎也没有更好的办法。下面列出了一些常用的题目模式\n    * _我是如何xxx的_\n    * _xxx的38个xxx（技巧、平台、工具、网站）_\n    * _xxx，看这一篇就够了_\n    * _xx屌丝的xx逆袭_\n    * _15年编程生涯，资深架构师总结的7条经验_\n* **图片**。一定要有一个封面图片，不需要内容非常相关，只要让人看了有食欲就行。这是另一个主题，无需多加发挥\n* **目录**。很多时候，可能没什么兴趣看完你的整篇文章，只要被标题吸引进来了，这时有一个目录（如[OSC](http://my.oschina.net/u/1581831/blog/704441)和[segmentfault](https://segmentfault.com/a/1190000005858229)）明明白白指示文章结构，粗略滚动一下屏幕，如果看着图片又多，排版又好，内容也不差，点个赞，存个书签，表示到此一游了，就可以关掉页面点击下一个了\n* **资源收集类**。比如一些awesome-list，资源收集、网站收集，点个赞，收藏个书签\n\n其实小细节我觉得都反映出的是一个问题，就是看文章对于我们来说似乎已经变成一种阻力极小的习惯，我们更倾向于在碎片时间进行这种更加轻松不用动脑的阅读，安慰自己时刻在学习，但其实并没有进行深入阅读的心境，长期而言，被消费的其实是我们的时间和思考能力。如何应对？以我为主，网络和平台都只是工具，真正核心在自己所爱所想。去坚持，去生活，把时间给自己，给爱的人，就足够了，别没事晒照片逛论坛了。\n\n—— 2016-07-03\n"},{"id":"2016-07-20-elegant-mac-intellij-shortcuts","title":"Mac优雅的工具集——Intellij快捷键","contents":"\n\n本篇是我Mac优雅工具集系列下其中的一篇文章，[原文全文](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)托管在Gitbook上，分享了Mac系统下一些使工作变得更高效的工具。\n\n> 在线的精简cheatsheet备查表：[intellij.linesh.tw](http://intellij.linesh.tw)  \n> Github项目：[intellij-mac-frequent-keymap](https://github.com/linesh-simplicity/intellij-mac-frequent-keymap)\n\n# Intellij Cheatsheet：成吨提高Java编程开发效率\n\nIntellij的快捷键多而繁杂，处女座的我这一年里，拉拉杂杂也阅读了大量的文档和资料，从[官方推荐的keymap](https://resources.jetbrains.com/assets/products/intellij-idea/IntelliJIDEA_ReferenceCard_mac.pdf)到市面能看到的大多数资料和总结。结合平时的工作和个人项目经验，我尝试整理并总结其中最精华的部分，并通过这个子集总结思考与提高效率相关的思维模式和理念。于是有了这篇博客。总的来说，它讲了两个内容：\n\n* 快捷背后的理念与思维模式\n* 一套精简的Intellij快捷键核心子集\n\n产出的价值大概有这么几方面：\n\n* 一个[在线的cheatsheet备查表](http://intellij.linesh.tw)\n* 总结了高效快捷键的一个精简子集，节省了阅读其他杂而价值不高的快捷键的时间与精力\n* 总结了快捷背后的两个思维模式的转变：**更高层级的抽象** 和 **声明式使用**\n\n## 理念与思维模式\n\nIDE与电脑作为工具，永远是高效完成特定工作的辅助。因此我们所谓的高效有了上下文：以完成工作为主，在这个过程工具的作用是辅助工作。那么，所谓高效也即是问，如何更专注于工作本身，更高效地完成工作呢？在一系列落地的快捷键背后，这个围绕快捷键所展开的工作系统，其实质性提高工作效率的理念和思维模式本身是什么呢？我的回答是：\n\n* 更高层次的抽象\n* 声明式使用\n\n### 更高层次的抽象\n\n更高层次的抽象，指的是从代码、从语言本身特性的层面思考编程，而非单纯的文本或者字符串。要把思维从“把这五行代码剪切并复制到一个新的方法里”等把代码当成无意义字符的低层面活动，转变到以作为语言核心的要素和特性为单位的思考，比如类、变量、方法、重命名、重构、if-else、循环、可循环元素等。\n\n在这方面，IDE提供的 **Live Template**、**重构(Refactoring)**、部分后向声明等，都是这种思想的产物，允许你从更高的层级（语言特性、与Java高相关的重构）来思考代码，并尽量多地向上屏蔽细节。\n\n### 声明式使用\n\n声明式使用，指的是直接使用你完成工作所需要的元素（类、字段、方法等），让IDE为你自动补全缺少的声明或定义。这种思想同样贯穿这本工具集的始终，以更语义化（更高阶）的操作来使用工具。\n\n在这方面，IDE提供的 **后向声明(Postfix Auto Completion)**、**自动补全(Auto Completion)** 等，都是这种思想的产物。你不需要关注操作所在的上下文，IDE会为你补全，你需要关注的是工作和操作本身。\n\n\n## 快捷键精简子集\n\n本节主要分七个部分展开总结：生产力大杀器、语言要素生成、编辑、导航、重构、搜索、运行时。版本控制的部分未录入，原因是我倾向于使用命令行提交，而非IDE内置VCS支持。见仁见智。最后一栏是该操作在IDEA中的操作名称，可以在keymap中检索对应的action/shortcut找到。\n\n### 生产力（Productivity）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---      |:---:        |:---:          |:---     |\n| 模板补全 | ⌘+J | 插入一个符合某结构特征的模板，详解见下 | Insert live template |\n| 命令查询 | ⇧+⌘+S | 以名称的形式查询某个操作或快捷键，是声明式编程思想的完美体现 | Find actions |\n| 意图预测与智能帮助 | ⌥+Enter | 简单重构、移除死代码、结构调整、自动导包等| Show intention actions |\n\n#### 模板补全（Live Template）\n\n敲完以下模板补全的keyword之后可以直接通过tab或回车触发模板补全，$1/$2...是需要你填充的模板变量。\n\n| Operation | Mac OSX 10.5+ Keyword | Expands to | Comments |\n|:---: |:---: |:---: |:---: |\n| 判空 | `ifn` | `if ($1 == null) {}` | 后向声明也有同样功能，读者可拣顺手的用 |\n| 判非空 | `inn` | `if ($1 != null) {}` | |\n| 创建索引循环 | `fori` | `for (int $1 = 0; $1 < $2; $1++) {}` | |\n| 添加TODO | `todo` | `// TODO: $1` | 非常声明式的用法 |\n| 添加Fixme | `fixme` | `// FIXME: 7/19/16 $1` | 同上 |\n| 类型关系判定 | `inst` | `if ($1 instanceof $2) {} ` | |\n| System.out | `sout` | `System.out.println($1); `| 必须入手的黑技能，调试打log的时候非常有用 |\n\n#### 后向声明（Postfix Completion）\n\n[后向声明](https://blog.jetbrains.com/idea/2014/03/postfix-completion)是JetBrains系IDE的一项新功能，旨在减少光标经常性的前后移动，提高开发效率，形成这样的编程思维：先使用元素，再考虑变量声明或结构补全。它的主要功能是根据当前元素的属性，提供可能的行为建议，例如使用if-else结构包围、判（非）空、格式化、进行类型转换等。因此，后向声明所能提供的选择视元素（主要是变量）的不同而不同。\n\n所有元素都拥有的一些后向声明选择，仅选择我认为常用的：\n\n| Operation | Postfix Completion Keyword | Expands To | Comments | \n|:---: |:---: |:---: |:---: |\n| 变量声明 | element.`var` | `Type $name = element;` | 必备技能，声明式使用的典范 |\n| 转换为类字段 | element.`field` | `private $Type element; ` | 刚发现的 |\n| 将当前变量打印到输出流 | element.`sout` | `System.out.println(element);` ||\n| 返回当前值 | element.`return` | `return element;` | |\n| 类型转换 | element.`cast` | `(($Type) element)` | |\n\n然后，对于特定的元素类型，有的后向声明还有非常实用的选项，比如字符串的判空、布尔值的if-else、列表的循环等等：\n\n| ElementType | Operation | Postfix Completion Keyword | Expands To | Comments | \n|:--- |:---: |:---: |:---: |:---: |\n| 字符串 | 判空 | string.`null`| `if (string == null) {}` | |\n| | 判非空 | string.`notnull` | `if (string != null) {}` | |\n| 整数 | 分支 | int.`switch` | `switch (int) {}` | |\n| 布尔值 | 如果为真 | boolean.`if` | `if (boolean) {}` | |\n| | 如果为假 | boolean.`else` | `if (!boolean) {}` | |\n| | 反义 | boolean.`not` | `!boolean` | |\n| 列表 | 循环元素 | lists.`for` | `for (Type element : lists) {}` | 非常常用 |\n| | 带索引循环 | lists.`fori` | `for (int i = 0; i < lists.size(); i++) {}` | |\n\n\n### 编辑（Editing）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 基本代码补全 | ^+Space | 一般都用这个补全，变量命名时及方法补全时常用 | Code/Completion/Basic |\n| 智能补全 | ^+⇧+Space | 是否有必要记得两个快捷键？可以统一设成一个 | Code/Completion/SmartType |\n| 语句补全 | ⇧+⌘+Enter | 直接补全当前语句，在括号特别多时非常有用 | Complete Current Statement |\n|||||\n| 从上方开始一行 | ⌥+⌘+Enter | | Start New Line Before Current |\n| 从下方开始一行 | ⇧+Enter | | Start New Line |\n| 上移/下移一行 | ⇧+⌥+↑/↓ | 上下移一行。一般用于以单行出现的元素，否则会破坏元素间的关系 | Move Line Up/Down |\n| 上移/下移一个块 | ⇧+⌘+↑/↓ | | Move Statement Up/Down |\n| 选中一个代码块 | ⌥+↑ | 常用 | Extend Selection |\n| 取消代码块选中 | ⌥+↓ | | Shrink Selection |\n|||||\n| 重复当前行 | ⌘+D | | Duplicate Current Line or Block |\n| 复制并且不删除当前行 | ⌘+C | | Edit/Copy |\n| 剪切当前行并复制到粘贴板 | ⌘+X | | Edit/Cut |\n| 关闭当前标签 | ⌘+W | 跟通常编辑器快捷键一致 | Edit Tabs/Close |\n| 注释当前行 | ⌘+/ | 随手一注释 | Comment with Line Comment |\n|||||\n| 优化import | ^+⌥+O | 没啥用 | Optimize Imports |\n| 格式化代码 | ⌥+⌘+L | 没啥用 | Reformat Code |\n\n### 语言要素生成（Language Elements/Features）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---      |:---:        |:---:          |:---     |\n| 测试、方法生成 | ^+Enter/ ⌘+N | 非常常用于创建测试方法、构造方法、覆写接口方法、覆写基类方法 | Code/Generate |\n| 创建类、文件、目录 | ⌘+N | 常用 | Code/Generate |\n| 创建override方法 | ^+O | 有用 | Override Methods |\n| 创建接口方法实现 | ^+I | 有用 | Implement Methods |\n\n### 导航（Navigation）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 转到方法/字段的声明 | ⌘+B | 调试跟代码都很常用 | Navigation/Declaration |\n| 转到方法/字段的实现点 | ⌥+⌘+B | 同上，常用 | Navigation/Implementation(s) |\n| 转到方法/字段类型的类定义处 | ⇧+⌘+B/ ⇧+^+B | 常由下两个快捷键取代 | Navigation/Type Declaration |\n| 当前类与单元测试间跳转 | ⇧+⌘+T | 非常方便 | Navigate/Test |\n|||||\n| 跳转到当前类的基类 | ⌘+U | 配套食用，效果更佳 | Super Method |\n| 类继承体系 | ^+H | | Type Hierarchy |\n| 方法继承层次 | ⇧+⌘+H | | Method Hierarchy |\n| 当前方法调用链 | ^+⌥+H || Call Hierarchy |\n| 本类及所有基类方法列表 | ⌘+F12 || File Structure |\n|||||\n| 类/方法/字段定义的快速预览 | ⌥+Space/ ⌘+Y | 小览实现，一般可以看到方法/字段参数、返回值、前几行实现，快速的信息足够了 | Quick Definition |\n| 方法文档快速预览 | ^+J | 看文档，我不常用 | Quick Documentation |\n| 方法参数快速预览 | ⌘+P | 常用 | Parameter Info |\n|||||\n| 前一个标签 | ⇧+⌘+[ | 导航常用，不过是否能以其他方式取代，比如声明式使用类查找⌘+O等。仍在探索 | Select Previous Tab |\n| 后一个标签 | ⇧+⌘+] | | Select Next Tab |\n| 往上一级 | ⌥+⌘+←/ ⌘+[ | 调代码，跟方法体系时，非常有用，下同 | Navigate/Back |\n| 往下一级 | ⌥+⌘+→/ ⌘+] | | Navigate/Forward |\n|||||\u0010\n| 转到下一个错误或警告 | F2 | 代码见红时，常用此快捷键快速定位，并配合万能快捷键⌥+Enter快速修复 | Next Highlighted Error |\n| 提示错误信息 | ⌘+F1 | 不常用 | Error Description |\n| 意图预测与智能帮助 | ⌥+Enter | 简单重构、移除死代码、结构调整、自动导包等| Show intention actions |\n|||||\n| project视图 | ⌘+1 | 有时导航项目结构时常用，不知是否有替代方案 | Other/Project |\n| search/find视图 | ⌘+3 | 除了这几个，其他视图都不常用 | Other/Find |\n| run视图 | ⌘+4 | 有时开关测试视图 | Other/Run |\n| debug视图 | ⌘+5 | | Other/Debug |\n| VCS视图 | ⌘+9 | | Other/VCS |\n| terminal视图 | * ⌘+0 | 自己改过，一是和各种视图快捷键保持一致，另外是原生的⌘+F12实在有点难按 | Other/Terminal |\n| 隐藏所有工具视图 | ⇧+⌘+F12 | 同时开了工程和终端视图时一键回编程页面 | Hide All Tool Windows |\n|||||\n| 跳转到第...行 | ⌘+L | 属于细节型的活，能少用就多思考替代方案 | Navigate/Line... |\n\n\n### 重构（Refactor）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 复制类/目录等 | F5 | | Refactor/Copy |\n| 移动类/目录等 | F6 | | Refactor/Move |\n| 元素(类/方法/变量/…)重命名 | ⇧+F6 | 最常用的重构快捷键之一了吧 | Refactor/Rename |\n| 类/方法签名修改 | ⌘+F6 | | Refactor/Change Signature |\n|||||\n| 字段(类级别)抽取 | ⌥+⌘+F | | Extract/Field |\n| 常量(类级别)抽取 | ⌥+⌘+C | | Extract/Constant |\n| 变量(方法级别)抽取 | ⌥+⌘+V | | Extract/Variable |\n| 参数(方法级别)抽取 | ⌥+⌘+P | | Extract/Parameter |\n| 方法抽取 | ⌥+⌘+M | 最常用的重构快捷键之一 | Extract/Method |\n| 方法内联 | ⌥+⌘+N | | Refactor/Inline |\n\n\n### 搜索（Searching)\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 搜索 | ⌘+F | 通常快捷键 | Find/Find |\n| 替换 | ⌘+R | 正则发挥作用的地方 | Find/Replace |\n| 查找引用点 | ⌥+F7 | 重构或调试的时候经常用到，使用频率高 | Find/Find usages |\n|||||\n| 查找类 | ⌘+O | 声明式编程，使用频率很高的快捷键 | Navigate/Class |\n| 查找文件 | ⇧+⌘+O | 同上，使用频率很高 | Navigate/File |\n| 查找symbol | ⌥+⌘+O | 基本不用，不知道与上两者有什么区别 | Navigate/Symbol |\n| 全项目文本搜索 | ⇧+⌘+F | 搜索引用点和文本出现、改bug时非常有用 | Find/Find in path |\n|||||\n| 查找下一个 | ⌘+G | | Find/Find Next |\n| 查找上一个 | ⇧+⌘+G | | Find/Find Previous |\n\n### 运行时（Runtime）\n\n| Operation | Mac OSX 10.5+ | Comments | Description |\n|:---:      |:---:        |:---:          |:---     |\n| 编译 | ⌘+F9 | 调bug时可能是忘了编译最新代码 | Make Project |\n| 运行(最近一个测试) | ^+R | 非常有用，有时可能节省在测试代码和源文件之间的切换 | Run/Run |\n| 调试 | ^+D | | Run/Debug |\n|||||\n| 打断点/取消断点 | ⌘+F8 | | Toggle Breakpoints |\n| 查看所有断点 | ⇧+⌘+F8 | | View Breakpoints |\n| 跳入 | F7 | | Run/Step Into |\n| 跳出 | ⇧+F8 | | Run/Step Out |\n| 智能跳入(当前行多个调用时) | ⇧+F7 |\n| 跳过(下一步) | F8 | | Run/Step Over |\n| 求表达式值 | ⌥+F8 | | Evaluate Expression |\n| 停止调试 | ⌘+F2 | | Run/Stop |\n"},{"id":"2016-08-07-tieba-final-summer-competition-review","title":"2016年五子棋贴吧★拯救玛利亚杯★ 备战录与棋评","contents":"\n\n报名比赛后有两周的时间，说起来因为每天要上班，因此实际的准备时间加进来其实不长，而且谱看多了有时还会恶心干呕。然后前段时间听了九指老师的高级班，对，我是顺便来安利一下九指的高级班的！听了高级班，讲到布局准备的一些东西，这次比赛里也有意识地去分析对手和准备开局。虽然针对个人的准备，最后都用在了别的人身上。\n\n总结起来，本次比赛发现自己还有很多不足，比如对于大型局面控制能力较弱、用时仍有不妥当的地方，中盘战斗力还要提高。好的地方是，尽力地准备了开局的变化，以及风格上还是在朝我喜欢的精准和暴力的方向发展。\n\n## 自我分析与可开局面分析\n\n一直以来，定式是我较弱的一块，尤其是复杂局面。计算力方面大概平均10步，在综合实力中应该不会成为短板。风格方面，我有意识地朝激烈、极限的方向去培养，喜欢进攻的快感。那么布局上如何通过准备，平稳地度过开局进入中盘，便是这次比赛准备的主要目标。\n\n局面方面，我也把26个开局在二打下结论和主观操作难度过了一遍，大致把它们分为三类：必胜并且不能主动开的局面、可战局面、超复杂局面。比如说：\n\n* 下意识排除的开局：寒星、恒星、花月、浦月\n* **必胜且不能主动开的局面**：主要是过于简单的一二打，或者通过简单套外势就能杀的局面，比如金星一打、水月两打、云雨月一打（二打还是有可考点）、明星一打、溪峡月两打等；\n* **可战局面**：黑白小优/中优局面，或即便理论必胜，但主观上仍然比较复杂的局面，比如银月二三打、明星二三打、残月、山新、名岚、流星等；\n* **复杂局面**：疏星、瑞星、松月、斜月。这些局面我觉得我还控制不太好。\n\n总结起来，开局的策略是这样：\n\n* 如果是实战经验丰富、综合实力明显比我强很多的选手，那么开疏星瑞星等大型局面我几乎必死，也即是说，被开局时不能开直指，开斜指，进入斜月或明星等局面；如果是我开局，斜指则用斜月，直指的话使用金星或疏星\n* 如果水平相当棋手，被开局随机应变，稳妥即可；我开局时则直指可下松月、疏星、金星等局面，斜指则云月二打、明星、斜月、银月等战斗局面都可以考虑\n\n下面上棋评。\n\n## 第一局\n\n> （人机6）普通的士兵：零度以下\n\n普通士兵自知不敌，一掌拍向了自己罩门，经脉尽断而忙。零度以下0手胜。\n\n## 第二局\n\n> 对局双方：零度以下【黑】：ran小小爱o【白】，不交换，5A-34，黑胜\n> 用时：零度以下 读秒0:58 ：ran小小爱o 03:25\n\n![](http://oa6tlgkic.bkt.clouddn.com/2.jpg)\n\n可以看到我开斜指的缘由。但事后觉得还是开一三打较好，这个定式执黑我没有变招的余地，感觉13、15的变招都容易死，没有勇气考。于是定式一口气摆到27，微妙之处是H12（39）这个点忘了盖。这个局面是我第一次下，因此其中各部要点我也不是很清楚。\n\n33、35的交换思路是利用上方的优势，借一些棋到下方来，各处攻击。因此如果36-37，37-36，黑棋上下联系依然存在。然而38防守时，忘记上方39要点，被黑棋抢占后即已无法防守。\n\n## 第三局\n\n> 对局双方：乱码经理【黑】：零度以下【白】，不交换，5A-7，白胜\n> 用时：乱码经理 03:54 ：零度以下 读秒 01:00\n\n![](http://oa6tlgkic.bkt.clouddn.com/3.jpg)\n\n刚坐下乱码就说度爹好，我就猜一定是群里攻攻受受中的某只了～原来是热爱妹子啊。不得不说，小号真是多。热爱开局，流星，一看这开局我就想得，戳中我毫无准备的局面了，那就只能遵循赛前以稳为主的作战方针，慢慢下了。想到这，我想那就留那个挡活二的5吧，于是我就点了一下，然后这5就被拿走了…\n\n短暂的戏虐啊不戏谑过后，其实觉得还好，6活三交换的定式我还是知道一些。定式正常进行到白10，黑11变招。脱谱第一手，马上长考（请听高级班）。不过这是比赛的第二局，说实话我脑袋还有点懵，不知道思考些啥，大致构思的是12、14的手段，黑棋眠三必挡，否则变化太多，迟早是后患。本来构思是若13反挡，14也走实战14，但这样14恰好是败，请见下面第一图拆解。\n\n长考5~6分钟后，实战12、14预想的手段，14的活二往上往下都有制作禁手进行进攻的手段，全局白棋比较生动，还是挺满意的。此时我主要考虑的是15-22这样挡外围的手段，不过热爱落下15的速度还是挺快的，我一看这是要包饺子啊！下12、14时没有考虑这样的15，于是临场算。实战时看到16、18的手段，已算到19的唯一防，觉得很有前途，于是花了剩余时间验证了16、18手段。落下时已读秒。不过20活三之后后面的进攻就比较清楚了，每分钟1步已经足够。白胜。\n\n![](http://oa6tlgkic.bkt.clouddn.com/3-2.jpg) ![](http://oa6tlgkic.bkt.clouddn.com/3-1.jpg) ![](http://oa6tlgkic.bkt.clouddn.com/3-3.jpg)\n\n第二图是实战13反挡时正确杀法，白棋强撸即胜；第三图是实战15挡外围时的杀法。\n\n## 第四局\n\n> 对局双方：落霞齐飞孤鹜【黑】：零度以下【白】，零度开局，小土豆交换执黑，5A-6，白超时负\n> 用时：落霞齐飞孤鹜 读秒01:00 ：零度以下 读秒 0:00超时\n\n哎呀，这局棋学到很多东西，对一个先手所能进行的进攻和控制有了更深的体会。同时，对于准备好的变化，真的还要在实战前拿去练练，看看实战起来这个局面究竟能不能走，一般棋手会怎么思考，要点在哪里，等等。\n\n我认识小土豆，他不认识我。根据贴吧发的一些棋来看，感觉谱量比较大，战斗经验也很多，擅长快棋，计算力不知道，但棋感应该很好。不过由于小土豆报名较晚，我没有对他进行准备。我还是认为拼瑞星疏星肯定是死了，既然大型局面拼不得，那就把之前准备的一个金星大招拿出来用用呗。然后刚好是我开局，小土豆给直指，布局就顺利进行了。\n\n![](http://oa6tlgkic.bkt.clouddn.com/4.jpg)\n\n实战走到10手之后，就是我在金星二打中搜刮出来的一套不是能很简单套外势杀的必胜。黑棋长考，在11手的选择上用了10+分钟，对于只有15分钟的比赛，真是感觉有魄力。11手正确应对，12继续预定的考，之所以选择这个局面，是因为黑棋虽然必胜，但经过事先拆解，右边局部黑棋的必胜点是唯一的，其他看似强劲的进攻要么速败，要么导致局面不能必胜。本来以为只剩几分钟13肯定走不出正解的了，不过实战的13我没有考虑过。此时小土豆即将进入读秒了，不过我并没有松懈，因为13刚好脱了我的谱，况且土豆快棋也很强，说明真正的战斗现在才开始。\n\n14的选择上我并没有进行太长思考，15、16也如预料，一是因为这个16我也拆过，右上无杀，并且既然对手已经读秒，此时战术应是快速应对，给予对手时间压力，同时一边寻找黑棋破绽。\n\n然而17落下我就擦了一声，很显然我之前并没有考虑到17这样控制的手段。冷静了一下，快速分析了一下局面。白没有必败，因为黑是走脱了必胜的，但毕竟是黑优局，黑看起来是联系全局进行控制的节奏，白必须小心防。一下就感觉前期的优势不存在了好么，然后18开始就是白棋的防守，黑棋也是本着全局联系的思路，凭选点的感觉做棋。白防守时既不能让黑直接出vct，也不能让黑太简单飘到其他局部，基本我下完防守就知道黑棋要往哪儿飘了，真是心碎…19虽然符合常理，但在我思维之外，做棋好手。\n\n38寻求激烈的手段复杂化局面，41后黑棋下方已是白棋一手棋即可防住。白要在上方争取主动侵占空间后，先手回防下面，再寻找机会。一切都是那么刺激，然而此时我超时了。\n\n![](http://oa6tlgkic.bkt.clouddn.com/nick-young-mengbi.png)\n\n金星二打准备的这个考是这样的，如下图。13是局部唯一能必胜的进攻，其他A~D的进攻看似强劲，其实都必败；15活三也是几乎唯一的进攻。\n\n![](http://oa6tlgkic.bkt.clouddn.com/4-1.jpg)\n\n细细想来，白棋防守还可斟酌，因为本局基本是被黑棋轻松控制的节奏。另外，要对考的局面有更深的理解，因为既然是考黑优局，就要面对黑棋各种各样的进攻手段，它们虽然客观上不必胜，但主观上若理解不深，很可能就是自己中招了。\n\n不过，最大的问题似乎还是考黑优局这件事本身。之前因为定式接触少，一直对一些传闻中黑优/黑好控制的局面没有认识，认为可战，但经此一战，对黑棋一个先手的力量算是有了感觉。如果实战黑棋非常容易控制，或者有非常强烈的骗，那么将非常考验白棋的耐心与实力。因此，黑平衡局的学习似乎对我而言变得重要。总结起来，开局算是成功，中盘细节处理有待提高。\n\n## 第五局\n\n> 对局双方：零度以下【黑】：残花灬赤瞳【白】，不交换，5A-3下，白胜\n> 用时：零度以下 00:37 ：残花灬赤瞳 02:17\n\n和小土豆的一局后，我觉得我还是得准备下平衡局，于是回来还是做了一些疏星的功课的，几个打点的前面10步不求甚解地看了遍。残花上一局的疏星也是用了这个6，我依然给这个5的打点，一是因为我做了一些准备，并认为残花有可能会选择自己熟悉的这个5进行战斗；二是根据我的准备，我认为是黑好走，并且没料到对手这么强。说白了，可能还是有点轻敌，不然还是不应该轻率地又给这个5。\n\n![](http://oa6tlgkic.bkt.clouddn.com/5.jpg)\n\n实战至15，完全在我的掌握之中，赛前主要准备的就是这个定式。棋情谱上就到这个15，此时我认为我的开局策略是成功的，度过了定式阶段，黑开始做棋。我还以为是黑优了呢，没想到是这样的结局！\n\n16，黑有左挡和实战两种手段。左挡在我看到下图的路线后，否定了，认为17后18跳三，然后就没有然后了。但实战20非常积极且强烈的手段！这个棋确实在我考虑之外，然而此时还没有死，另一个错就是此时的21我应该长考。而实战简单排除了一些线路（而非细算）之后就选定了21的防守。心浮气躁了。后面白理论必胜无误，实战自然但漂亮的追杀。\n\n第一次拼疏星就惨挂。这局棋，出现了我意料之外的20这样的手段，白优势局面下没有处理好，我服，学到了东西。不过，21自己没有长考选择好防守，也是心态还不够踏实的表现。同时，平衡局看来真是需要深入学习，并非背背谱就可以。也许其他事情也是这样的，一个事情要做到极致，必然需要积累和沉淀。精神应该在学习本身，体会当下学习的乐趣，而非执着于学到了多少、是否已经变强了这样的“结果”，心应该更沉静。这是需要时刻提醒自己的。\n\n![](http://oa6tlgkic.bkt.clouddn.com/5-1.jpg)\n\n如上图，17防活二外侧，18以下的进攻其实并不成立，25-A即可。\n\n## 第六局\n\n> 对局双方：聆视仙诉【黑】：零度以下【白】，不交换，5A-6左，白胜\n> 用时：聆视仙诉 08:31 ：零度以下 读秒01:00\n\n![](http://oa6tlgkic.bkt.clouddn.com/6.jpg)\n\n看了一下仙诉前几轮的对局，感觉云月准备的有一路变化可以使用。不过黑7直接脱了我谱，而且和他对阵上一轮对手的7是同一个。白棋小心应对，毕竟是黑优局。28、30的进攻我觊觎已久，不过有几个防守找不出局部杀，所以22~26一直在上面积攒些材料。32果断转身，也是没办法中的办法，因为此时我又快读秒了，上面的杀法尽管没有地毯，但也只好一试。37直接防守就被简单抓三三了。\n\n本次云月准备的局面是下面两个。左图考点一是在15，二是在21，这一路是黑棋必须非常精细敢走才能杀出，本来是想着对于喜欢套外围而疏计算的棋手能用上；右图则是存在21这样的后中先妙手。\n\n![](http://oa6tlgkic.bkt.clouddn.com/6-1.jpg) ![](http://oa6tlgkic.bkt.clouddn.com/6-2.jpg)\n\n## 第七局\n\n> 对局双方：欲语泪流kun【黑】：零度以下【白】，不交换，5A-2右，白掉线日了汪怨念脸，和棋\n\n![](http://oa6tlgkic.bkt.clouddn.com/7.jpg)\n\n12开始已经有vct，我是有想过，还算不清。14局后拆解，接近必胜，进攻还是挺爽的，然而爽到一半突然断线。就不说啥了。对家最后还是说和棋，没有直接算负，还是很感谢。\n\n棋评结束，没有总结。谢谢阅读 :)\n"}]