[{"id":"2016-03-11-elegant-mac-iterm2","title":"Mac优雅的工具集——iTerm2篇","contents":"\n\n本篇是我Mac优雅工具集系列下其中的一篇文章，[原文全文](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)托管在Gitbook上，分享了Mac系统下一些使工作变得更高效的工具。\n\n# iTerm2实用特性 Handy Features\n\n这里的参考：[https://www.iterm2.com/features.html](https://www.iterm2.com/features.html)\n\niTerm这个终端具有比系统默认终端更强的能力，而term3则是最近刚发布的beta版本。它比起系统默认终端具备更加丰富且实用的功能，比如：\n\n* 窗口切分(Split Panes)\n* 即时窗口(Hotkey Window)\n* 搜索，支持正则表达式\n* 全键盘复制(Mouseless Copy)\n* 自动补全(Auto Complete)\n* 粘贴版历史记录(Paste History)\n* 即时回放(Instant Replay)\n* 触发器(Triggers)(虽然还不知道是什么鬼)\n* ...等\n\n\n## 窗口切分 Split Panes\niterm2支持把窗口进行横向纵向切分，自己可以调整占据的比例，并且不活跃的窗口（inactive panel）还会变暗以强调活跃的窗口，对于需要一个工作区间做多件事的需求是很有用的。\n\n![iTerm2-panes-split](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-panes-split.png)\n\n* 纵向切分：`Command+D`\n* 横向切分：`Shift+Command+D`\n* 窗口切换：`Command+[` / `Command+]` / `Option+Command+Left` / `Option+Command+Right`\n\n\n## 即时窗口 Hotkey Window\nhotkey windows让你在任何地方都可以打开终端执行一些命令，对我来说应用最多的场合，应该是在搜索一些问题的时候，对于一些需要输入命令的解决方案可以即时拷贝命令，打开终端来输入。比如，现在我在搜索“如何安装zsh语法高亮的插件”，然后找到了zsh语法高亮插件的官方github，一共有三个步骤，我可以立即就打开iterm2的hotkey window，拷贝git clone的命令拷贝仓库，再打开一个窗口用vim修改`~/.zshrc`文件的内容，然后`source`一下，高亮搞定！\n\n![iTerms2-hotkey-window](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-hotkey-window.png)\n\n* 全屏切换：`Command+Enter`。全屏模式切换在hotkey window下尤其顺滑，太赞！！\n* 窗口模糊度toggle：`Command+U`\n\n\n## 搜索与全键盘复制粘贴 Search and Mouseless Selection\n这个功能其实我不太常用，就是可以在iterm2窗口中搜索内容，跟在编辑器中搜索一样，支持正则表达式搜索。此外，还支持选中当前搜索内容一键复制等，功能强大，就是没怎么用到。\n\n![iTerm2-search-and-mouseless-selection](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-search-and-mouseless-selection.png)\n\n* 搜索：`Command+F`\n* 复制选中内容：`Enter/Return`\n* 拓展选择（反向拓展）：`tab/Shift+tab`\n\n\n## 自动补全与粘贴板历史 Autocomplete and Paste History\n只要是在终端输入过的词或者命令，iterm2就可以帮你提供自动补全的建议，快捷键是`Command+;`，调出后即可通过纯键盘输入来筛选，比较适合快速输入一些长命令，如下，其快捷键也比`Control+R`友好一点，可视化程度更高一些。在其他相似的场景下，这个功能有一些替代品，比如目录导航时使用autojump/z、搜索历史命令时使用`Control+R`、`history`等。\n\n另外，iterm2也帮你保存了你粘贴过的命令，通过快捷键`Shift+Command+H`即可调出，但仅限于通过粘贴板的方式进入的命令。\n\n![iTerm2-autocomplete](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-autocomplete.png)\n\n![iTerm2-paste-history](http://7xqu8w.com1.z0.glb.clouddn.com/iterm2-paste-history.png)\n\n\n## 即时回放 Instant Replay\n逆天功能，可以回放过去任一**时刻**里iterm窗口的状态，在你需要之前窗口的一些信息时特别有用，可以回过去查看。虽然我不怎么用到这个功能，但你知道出事了随时都可以回去查看以前的信息。快捷键是`Option+Command+B`，每个session的即时回放缓存默认是4MB，可以在设置里面改。\n\n\n## 智能选择 Smart Selection\niterm2能够只能识别邮件地址、URL、文件名、文件夹等名称，按住`Command`键点击即可去到相应的地方。比较handy，用处不小也不大。\n\n\n## 系统配置\n\n### 要打开的选项\n\n* General -> Closing -> Confirm 'Quit iTerm2' command。`Command+Q`离`Command+W/1/2/3/Tab`如此之近，保不齐你什么时候手一滑按错所有窗口就都归西了\n* Appearance -> Window -> Hide scrollbars。据经验基本没必要，没用的元素就不打开让它占据空间\n* Profiles -> Text -> Cursor: Underline, Blinking cursor，光标指示符采用下划线并且加闪烁效果。个人喜好\n* Profiles -> Text -> Font: 12pt Monaco，此字体甚好\n\n### 要关闭的选项\n\n* General -> Selection -> Copy to pasteboard on selection。选中即复制，这不烦人嘛\n* General -> Window -> Adjust window when changing font size。比较建议关掉，虽然调整字体大小的时候不常见，但若窗口大小跟着变又得调窗口大小\n* Appearance -> Tabs -> Show tab close buttons。有`Command+W`和`exit`就行了\n* Keys -> Navigation Shortcuts -> To switch split panes，关掉\n* Keys -> Navigation Shortcuts -> To switch windows，关掉\n\n\n## 快捷键\n除了上面提到的在一些场景下比较常用的快捷键，这里尽可能地要精简整个软件所使用的快捷键，其他不常用的能删都删了。\n\n* `Shift+delete`，打开hotkey window，这里更改了默认的配置，因为空格的组合其他程序都在用，比如`Control+Space`是Intellij的上下文提示，`Command+Space`是Alfred/Spotlight的全局快捷键，`Option+Space`是系统默认的幻灯片播放，`Option+Command+Space`被我也因为前面快捷键被占的原因被我定制成输入法切换，`Shift+Space`是输入法的简繁体切换。太难记了，所以hotkey window的快捷键不这么用\n* `Control+A/E`，系统默认的快捷键，师承vim系风格，分别是跳到行头/行尾的快捷键，在编辑的时候对效率有一定帮助\n* `Command+Up/Down`，上一行/下一行\n* `Control+U`，直接删掉一行"},{"id":"2016-03-13-elegant-mac-oh-my-zsh","title":"Mac优雅的工具集——oh-my-zsh篇","contents":"\n\n本篇是我Mac优雅工具集系列下其中的一篇文章，[原文全文](https://linesh.gitbooks.io/gitbook-elegant-mac-tools-system-closure/content/index.html)托管在Gitbook上，分享了Mac系统下一些使工作变得更高效的工具。\n\n# oh-my-zsh\n\n有了一个趁手的终端，大的功能就算有了，接下来是一些小的细节的优化，比如主题，自动补全，三方插件集成等。因为[oh-my-zsh](http://ohmyz.sh/)太过有名，为我节省了一些选择的时间，也就不需要再考察其他选择，用了再说。其主页的介绍也是相当不低调，说用上一个主题，马上就会被别人当成极客中的大神，过来围观问你这个主题这么漂亮是怎么配的。然后深藏功与名的你，马上就会在程序员中作为神话被广泛传颂。\n\noh-my-zsh的两大主要功能分别是：\n\n* **主題（themes）**\n* **插件（plugins）**\n\n## 工作目录与配置文件\n[首先需要安装一个zsh](https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH)，安装方法在此不详述请点击链接或查看官网。安装时需要提前装好`git`、`wget`或`curl`工具。\n\nzsh默认的安装位置是在`~/.oh-my-zsh`文件夹下，同时在你的根目录`~`下会有一个配置文件`~/.zshrc`，这个配置文件非常重要，我们的主题和插件都是在这个文件里面配。同时它做好一些准备工作后，会去调用`~/.oh-my-zsh/oh-my-zsh.sh`文件设置好启动zsh所需的所有路径、加载完主题和插件。这个脚本源码值得阅读，官方文档中提到的许多特性都在这个脚本中体现，比如定制自己的配置、主题和插件等时的目录约定、定制主题优先于默认主题的加载、空/随机主题的配置和加载、自动更新等。配置好`~/.zshrc`文件后，`source ~/.zshrc`一下即生效。\n\n\n## 主题 Themes\n所有的主题都在`~/.zshrc`脚本的`ZSH_THEME`一行中配置，个人喜好是使用`\"random\"`值，每次zsh启动时都会随机加载一个主题。所有的官方标配主题都放在`~/.oh-my-zsh/themes`文件夹中，也可以[前往官方wiki之主题篇查看效果](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)。另外目前官方已不接受更多的主题提交请求，所以用户自己定制的一些主题则要前往[External Resource](https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes)查看。\n\n![zsh-random-themes](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-random-themes.png)\n\n![zsh-random-themes-fino-time](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-random-themes-fino-time.png)\n\n\n## 插件 Plugins\n就我所了解，zsh的插件并不提供实质性的功能，比如`git`插件，并不会自带git的命令行工具。插件提供的更多的是**集成**和**alias**的功能，只是为了让你在终端能更好更快地使用它。当然也有一些提供了便捷功能的插件，比如目录自动跳转等。\n\n插件开启在`~/.zshrc`文件的`plugins=(git ...)`一行配置，加入插件名并以空格分隔即可。所有的插件都已经放置在`~/.oh-my-zsh/plugins`目录下了。下面推荐一些个人比较推荐的插件，更多的插件可以在[github的官方wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview)查询。\n\n\n### 自动跳转 Fast Jumping \n* `autojump`。没有结果预览，不太友好\n* `z`。UI非常友好，并且有多个结果时支持使用TAB键进行导航特点是刚开始用要先进去你的目录让它“学习”\n* `wd`。可以给特定的目录“注册”（`wd add name`）别名，然后直接输入别名即可进入目录，特点是只能跳转到已注册的目录。但支持键盘操作，属于…可有可无的插件\n\n目前题主我三个工具都启用了，但打算关闭autojump，因为觉得z的UI更加友好\n\n![zsh-plugins-autojump](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-autojump.png)\n\n![zsh-plugins-z](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-z.png)\n\n![zsh-plugins-wd](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-wd.png)\n\n\n### 更简短的快捷键 Alias\n* `git`。首推git插件，它提供的是一个**全球统一**的alias，只要是使用zsh的终端都可以使用同样的缩略命令，常用的有比如`gst` `gca` `gca!` `gcan!` `gup` `gp` `gcb` `gcf` `gcm` `gco`等，完整的命令列表可以参考[zsh-git github的官方wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git)\n  ![zsh-plugins-git](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-git.png)\n* `sublime`。使用统一的`st`命令启动sublime，为你屏蔽了sublime可能混乱的安装位置\n* `history`。提供了`h`代替`history`，提供了`hsi`命令来搜索带特定字符串的历史\n\n\n### 自动补全、搜索与语法高亮\n* [git-completion](https://github.com/git/git/blob/master/contrib/completion/git-completion.zsh)。git命令的自动补全\n* [zsh-completion](https://github.com/zsh-users/zsh-completions)。zsh命令的自动补全\n* [zsh-syntax-highlighting](https://github.com/zsh-users/zsh-syntax-highlighting)。简直美妙\n* [zsh-history-substring-search](https://github.com/zsh-users/zsh-history-substring-search)。简直美妙，其实我看不太出来哪些补全是哪个插件做的，总之一口气全部装上就对了。zsh的语法高亮插件会在你命令输错的时候变红，下面是总的效果图\n\n![zsh-plugins-complete-overview](http://7xqu8w.com1.z0.glb.clouddn.com/zsh-plugins-complete-overview.png)\n"},{"id":"2016-03-17-a-module-require-confusion","title":"说开去——项目的JavaScript模块化实践（上篇）","contents":"\n\n> 为保护商业机密，本博客中出现的所有代码与文字均已隐去所有与客户相关的信息。若仍有泄露请第一时间联系博主我：linesh.simpcity@gmail.com。\n\n## 原生JavaScirpt也自带了模块化支持？\n起因是这样的，今天发现项目上的每个js文件基本都是这样的写法：\n\n```javascript\nmodule(\"module.name.bainianlaodian\", (function() {\n   function isValidRequest() {\n      // implementation;\n   }\n   return {\n      isValidRequest: isValidRequest\n   }\n}()))\n```\n\n然后在外部引用的时候只需要使用`module.name.bainianlaodian.isValidRequest()`就可以调用模块内的函数了，而且可以引用任意路径下的js文件。我就有点好奇，什么时候JavaScript有模块了？一般都是通过[IIFE](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)和闭包结合的方式来人为地创建一个“模块”，但并未看过这种直接调用的写法。而且引用时的路径是在哪里指定的？虽然靠猜也可以大概猜到，这个只需要通过维护一个全局的map记录模块名和对应的函数即可做到，不过还是挺有兴趣看一下具体的实现。于是问了一下项目组的同事，大家也表示不太清楚这个`module`及用法。那就`Ctrl+B`一下，看一下`module`这个变量的定义点吧，Intellij给出的提示是：\n\n```\nmodule (externs.js, src/main/webapp/.../bower_components/xdate/build)\nmodule (colors.js, node_modules/grunt/node_modules/colors)\nmodule (cli.js, node_modules/grunt-contrib-jslint/node_modules/jslint/node_modules/cli)\nmodule Window (qunit.js, src/main/webapp/.../bower_components/modernizr/test/qunit)\nmodule Window (qunit.js, src/main/webapp/.../bower_components/underscore/test/vendor)\n...\n```\n\n看着都不像，而且都是通过`npm`或者`bower`引进来的工具。我所期待的结果，应该是类似于nodejs或者类似的框架或环境所提供的变量和加载方式，类似于[这篇文章](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000)讲到的模块加载的方式。嗯，既然蛮干无用，那就求助一下程序员的~~好基友~~良师益友Google吧：\n\n### Google也解决不到的问题\n\n* `javascript module`\n* `jquery module`\n* `javascript module(\"\", function() {`\n* `commonjs module`\n* `nodejs module`\n* `amd javascript module`\n* `es5 javascript module`\n* `es6 javascript module`\n\n用以上的方式作为关键词，均没有找到什么有价值的线索。nodejs中虽然存在`module`这么一个变量，但是项目中的这些js代码没有在服务端执行的可能。Google了一下也没有发现是jQuery或者CommonJS规范里的内容，es6中有模块的概念，但使用的是`import`的关键词。这下可没有线索了，我更加怀疑这个`module`是项目里自己定义实现的了。但是从定义处入手并不能找到有价值的线索，那怎么办呢？既然IDE也无法给出有效的提示，那我就做一下人肉搜索咯，`Ctrl+Shift+F`全文搜索一下`module`这个关键词！过了两秒钟，IDE弹出一个对话框说\"1,001 occurrences found so far. Are you sure you wish to continue?\"额的神啊，看来这个刨根问底还真不容易，不过既然这是唯一的线索了，那果断还是要Continue的。于是我拍下了Continue，一共有7455处地方出现了`module`这个词。茫茫词海中，该如何捞到有价值的线索呢……？\n\n### 谜底水落石出\n\n有意思。由于搜索的名字太过宽泛，所以必然有很多不相关的结果，应该选择性忽略。比如`pom.xml`、`build.gradle`、`npm-debug.log`、test/`node_modules`/`bower_components`/java代码文件夹下的一切东西，最后发现了两个挺有可能相关的文件，一个在`laodian-libraries.generated.js`文件中，另一个在`js/common`文件夹下的一个`module.js`文件里。前者一看就是生成的代码，代码如下：\n\n```javascript\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n```\n\n看起来好像有点关系，其实并没有。这段代码是在做运行环境的检测，若是underscore是运行在服务端，就把`_`注册到`module.exports`变量中作为模块暴露出去；若是运行在浏览器端，则把`_`注册到全局对象`root`中去。这个`root`在某处其实也是被赋予全局变量`window`的值的。同时，这个文件也确实是打包生成的，打包是由`Gruntfile.js`中配置的`concat` task来完成的。真是又增长了知识。\n\n好消息是，在`js/common/module.js`这个文件里，我们似乎找到了想要的答案：\n\n```js\n(function(global) {\n\n  global.module = function registerModule(moduleName, moduleContent) {\n    var root = global;\n\n    if (moduleName.indexOf('.') == -1) {\n      registerToContext(root, moduleName, moduleContent);\n    } else {\n      var contexts = _(moduleName.split('.'));\n      var context = contexts.initial().reduce(function(memo, current) {\n        if (!memo[current]) {\n          memo[current] = emptyModuleObject();\n        }\n        return memo[current];\n      }, root);\n      // 这段代码会返回倒数第二个子模块，并为模块树中还不存在的子模块创建一个空的对象\n      // 并注册到其父模块中。优雅简洁的函数式编程，mind-blasting... [\"Mind Blasting\"][1]\n\n      registerToContext(context, contexts.last(), moduleContent);\n    }\n  };\n\n  function registerToContext(parentContext, moduleName, moduleContent) {\n    // 这个注册机制决定了新定义的模块不能覆盖已有的同名模块，而会直接被丢弃\n    var module = parentContext[moduleName];   \n    if (!module) parentContext[moduleName] = moduleContent;\n  };\n})(this); // this === window\n```\n\n**这套自定义的模块加载机制，它会将模块名解析成一个有包含关系的模块树，然后将所有模块及其之间的关系“注册”（其实就是加）到全局的`window`对象中。所有js代码对“模块”的引用其实都是在直接引用全局对象`window`下的变量，因此也无需配置具体的路径。**\n\n看到这里，一开始关于“模块的注册和运行机制”的问题似乎就完全清楚了。在浏览器中实际调试了一把还发现，`laodian-libraries.generated.js`是在`module.js`之前运行的。但是这里我发现了一个细节：实际被发送到客户端的js文件并不叫`module.js`，而是叫`laodian-basic.js`。搜索了一下`module.js`，**竟没有被引用的地方！**这让我不仅又想探索一个问题：这个js究竟是在什么地方被include到页面上的？什么时候被include进来？发布前又被做了什么操作？作为一个基础设施型的js，应该是每个页面都需要的，那么项目上是采用什么方式来实现这个事情的？\n\n欲知后事，请听[下文](#/posts/2016-03-21-javascript-package-compress-template-and-reuse)分解。\n\n"},{"id":"2016-03-21-javascript-package-compress-template-and-reuse","title":"说开去——项目的JavaScript模块化实践（下篇）","contents":"\n\n> 为保护商业机密，本博客中出现的所有代码与文字均已隐去所有与客户相关的信息。若仍有泄露请第一时间联系博主我：linesh.simpcity@gmail.com。\n\n## 再次出发\n\n在这个说开去系列的[上篇](#/posts/2016-03-17-a-module-require-confusion)中，我们已经回答了项目自带的模块化的实现，同时也带出了更多的问题，总结起来有以下这些。它们是本篇视图回答的问题：\n\n* `module.js`是如何被打包到`laodian-basic.js`中去？\n* 我们找到的这个js是在什么地方被include到页面上的？\n* 什么时候被include进来的？\n* 项目上用了什么方式来复用include这个js的那段代码？\n\n### 如何打包？\n上面我们还留下了一条线索：`laodian-basic.js`。既然`module.js`没有被引用的地方，那么就搜索下`laodian-basic.js`的引用点。这里我看到了两个引用点：\n\n1. ```jawr.js.bundle.laodian.id=/bundles/laodian-basic.js```\n2. ```<laodian:script bundle=\"/bundles/laodian-basic.js\" useVersionNumber=\"true\" />```\n\n看来似乎是配置了一些东西，然后直接在前端jsp(咦前端jsp怎么听起来怪怪的)通过`jsp tag`来引用。其中，第一个文件位于一个`jawr.properties`文件下，第二个文件的目录结构如下图所示。\n\n![brand-specific-jsp-directory-structure](http://7xqu8w.com1.z0.glb.clouddn.com/a82b64e24b984d2a92c0c39397481825.png)\n\n百年老店的项目有一个特点，就是支持多品牌，同一套代码需要服务不同地区的用户。我们挑了一个服务于大英地区的文件`british.jsp`，`Alt+F7`之，不能找到它的引用点。如我们第4点所要探索的问题所指出，由于要支持多品牌多页面，这个文件可能最终是通过这样的形式来被使用的：`<%@ include file=\"${brand}.jsp\" %>`（手动反射）。这个目前还没有太多线索，那么先看看第一条线索，Google一下[jawr](https://jawr.java.net/index.html)：它是一个可配置的、支持共用开发与发布代码的JS/CSS文件压缩与打包工具。配置简单：\n\n```java\njawr.js.budnle.laodian-basic.id=/bundle/laodian-basic.js\njawr.js.budnle.laodian-basic.child.names=laodian-pages\njawr.js.budnle.laodian-pages.mappings=/js/laodian-pages/**/*.js\n```\n\n看到上面这段代码就很清楚了，jawr会把`/js/laodian-pages/`文件夹下的所有js文件打包到`laodian-basic.js`文件中。JAWR其实还有一个`JawrServlet`，它会去读取`jawr.properties`(在`web.xml`文件的`init-param`配置`configLocation`)中的配置，并且拦截所有匹配`/js/*`的路径。\n\n\n### js是如何被引用到页面上的？——SiteMesh\n从上面搜搜到的这段代码已经可以看出，`laodian-basic.js`这个文件是在`british.jsp`中被引用的，后者引入了大量的CSS/JS/FAVICON等文件，似乎是一个入口文件，但它却没有再被其他文件引用：\n\n```html\n<head>\n  <script type=\"text/javascript\" src=\"laodian/common/js/laodian-libraries.generated.js\"></script>\n  <script type=\"text/javascript\" src=\"laodian/common/js/bootstrap.generated.js\"></script>\n  <home:script bundle=\"/bundles/laodian-basic.js\" useVersionNumber=\"true\" />\n\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"laodian/british/css/british-specific.less\" />\n</head>\n\n<body id=\"${activePage}\" class=\"${activePage}\">\n  <decorator:usePage id=\"specific-page\" />\n  <div class=\"page\">\n    <header class=\"Header\">...</header>\n    <main id=\"main-wrapper\">\n      <decorator:body />\n    </main>\n    <footer class=\"Footer\">...</footer>\n  </div>\n</body>\n```\n\n笔者眼尖，看到了`<decorator>`这个标签。它是SiteMesh框架定义的一个标签，sitemesh是一个分离页面内容和展现（presentation）的轻量级框架，其设计中运用了四人帮的装饰模式。Google Trends了一下它的热度，以及与它同类型的一些产品/框架的趋势，如下图，看起来似乎都要挂了。sitemesh3/tiles分别已经1/2年没维护了，只有wicket还在持续对Java8增加支持。这是不是意味着它所依附的模板技术也差不多日暮西山了？而模板技术又是前后端难以分离的一个重要的点，其实也从侧面印证了前后端分离的大趋势吧。\n\n![Trends-jsp-freemarker-etc](http://7xqu8w.com1.z0.glb.clouddn.com/f366e36a7e197a73e0b3cb46c563658d.png)\n\n![Trends-sitemesh-tiles-etc](http://7xqu8w.com1.z0.glb.clouddn.com/0b4e597eb0f1fba6eefa6c0d774e0961.png)\n\nAnyway不要跑题，火速看一下sitemesh的[文档](http://wiki.sitemesh.org/wiki/display/sitemesh/Setup+SiteMesh+in+5+Minutes+or+Less)，寻找启动项目的配置文件：`decorator.xml`！搜索一下项目的对应配置文件，果然有。看它的配置文件：\n\n```xml\n<decorators defaultdir=\"/WEB-INF/decorators\">\n  <decorator name=\"master-decorator\" page=\"main.jsp\">\n    <pattern>/british</pattern>\n    <pattern>/america</pattern>\n    <pattern>/...</pattern>\n  </decorator>\n</decorators>\n```\n\n这段代码在向我殷殷诉说：从特定路径下来的页面请求都会被`main.jsp`文件所前置装饰，再看到`main.jsp`文件：\n\n```java\n...\n<%\n  try {\n    String target = getLocale();\n    request.getRequestDispatcher(\"/WEB-INF/decorators/\" + target + \".jsp\")\n      .include(request, response);\n  } catch (...) {\n%>\n```\n\n这段代码也验证了我们一开始的判断，即我们是通过类似`${locale}.jsp`的形式来引用目标jsp文件的。至此所有实现都已经很清楚了：**通过SiteMesh对所有待渲染页面进行装饰，根据不同的地区分配到不同的`${locale}.jsp`模板去，后者再开始加载框架性（module模块化实现等）代码，最后渲染一般的html/js/jsp(template)。**\n\n## 总结与思考 Further Thinking\n\n许多时候一个项目的框架已经搭好，我们在使用的时候很少不会接触框架性的部分，比如js/css的压缩加载过程、多品牌的处理、框架选型等。既要写好业务代码，对于技术代码框架代码也要多了解，学会自己选型、搭脚手架。本文上篇讨论的其实是模块化的问题，下篇话题擦了模板技术的一点皮毛。深挖下去，还有许多问题可以了解：\n\n* 模块化的现状与实现。包括吕立青在[这里](http://blog.jimmylv.info/2016-03-10-getting-webpack-done-and-js-module-history)提到的一些相关技术或规范：CommonJS/AMD/WebPack/Browserify/NodeJS等\n* 模板技术。模板技术是依托于后端技术选型的，在选型的时候必须考虑现有的技术构架和迁移成本。另外在讨论模板技术孰优孰劣之前，也有必要先思考一下它所依托的后端框架的发展现状，比如Spring的生态圈（MVC/Boot)，比如是否必须要用Java来写后端代码等\n"},{"id":"2016-03-28-quick-coding-bibles","title":"唯快不破——快速编码实践","contents":"\n\n# 必先正名 —— 何谓快\n\n在谈论快之前，有必要先讨论一下何谓快。我的定义是，快不是速度快，而是效率高。当然许多场景下，速度快了效率自然就高。“效率高”又有两个延伸问题需要定义：\n\n* **做何事的效率？也即“快”的目标**，比如我要你2分钟洗5个梨，你说我洗10个苹果只需要1分钟，这种快跟目标不合就没用\n* **为何要高效率？**\n\n总结了一下半年多来的工作经验，我认为软件行业暂不讨论与人相关的因素下，技术工作需要具备三个能力：基础能力、快速构建能力、工程能力。这三项不在本文仔细展开，其中快速构建能力是指就一个项目需求或实际的工具需求，能使用已有知识和工具快速搭建出可工作的原型的能力。本文的快，（可能狭义地）认为是这种 快速适应项目或搭建应用 的快。\n\n为何要高效率。为节省出时间和脑力，以获得学习更多东西的机会。像挣更多钱这种大~~俗~~实话这里就不说了，好歹也是一枚文艺青年不是……【捂脸】\n\n# 快速编码笔记\n\n要在已有项目上完成添加或修改工作，不同的人可能有不同的方式。这里说说上了项目后学到的一点，即是采用 **直接定位修改点** 的方式。相比起了解整个系统的流程与工作原理，它更快，也更直接，是短平快的工作方式，有其学习的价值。对系统从头到尾的架构和细节了解，是课外的功夫，也有经验和积累，属于程序员的自我修养。因为我自己是~~处女座~~对原理更感兴趣的性格，在面对问题的时候会想先探究是如何实现的，有时就会阻碍学习或者解决问题的进度。这种不问为什么的理念，我觉得是个很好的补充。\n\n## 快速解决问题小笔记\n\n总结起来，在 **不问为什么，直接定位出错/修改地点** 的理念下，产生了一些直接但有效的实践，与我所见闻有很大关联，仅是学习笔记和抛砖引玉。这部分欢迎各种补充：linesh.simpcity@gmail.com。\n\n1. **看日志/控制台的输出信息，直接定位到问题发生的地点(controller, js, html element, etc...)**  \n  如果不知道日志的位置，可以观察项目的目录结构，或者跟踪Logger代码中的路径\n\n2. **GDT-Google Developer Tools的元素查看(Inspect elements)**  \n  可以通过id或class等特性有针对性地找到特定的元素，并借此搜寻作用于其上的绑定(比如jQuery、css等)\n\n3. **查看类或接口的所有实现(Command+Option+B in Intellij)**  \n  这里也是只能靠猜测的地方.但凡接口的实现必然有注入的地方，但在注入点到我们的调试点中间链可能很长，这样，只能通过找寻接口所有可能的实现，根据项目的实际情况，猜测_**注入发生的地点**_和_**被注入的实际类型**_，直接找到注入类，忽略中间过程。\n\n  **深入思考：**\n\n  接口提炼意味着所有可能被注入的对象存在着逻辑上（软件架构上，而非字面上）的联系。这里的实现，可能是指类或接口，也可能是字符串，其他类型的东西。实际的注入方式可能有以下几种：\n  * **字符串拼接**。这种情况说明待拼接串具有字面上的相似性（通常也反映了逻辑上的相似性），只是简单的文本填充。但其本身作为解耦的字串，可能暗示了其更高层使用者之间存在的逻辑联系。\n\n  * **反射**。我的毕设专题。它不同于手动声明对象的方式，它把“声明对象（包含为其申请内存，构建一个对象的过程）”这个动作从语言层面再次解耦出去。\n\n  * **混合使用**。其实这两种方式在Java中是以某种联系紧密连接的。字符串是反射特性使用的解耦符。它实现解耦的目的达到，在反射技术整个发展路上来看，这个技术的使用也是利大于弊的，但它也是有缺点的。抛开性能缺陷不说，它实现解耦的方式是把应用层的问题下放到语言层（虚拟机层），这样语言层面的代码可读性就消失了，你调试的难度就要增加。\n\n4. **spring mvc的RequestMapping注解找映射路径**\n\n5. **通过服务器(Tomcat, Jetty等)的配置文件找访问路径**  \n  只要路径不是自动生成，最终都是组织到配置文件来解决的节奏。\n\n6. **观察依赖管理工具的配置文件来看其引入的依赖**  \n  项目常用的管理工具有：\n  * 前端开发工具依赖管理npm(package.json)\n  * 前端开发库依赖管理bower(.bowerrc, bower.json)\n  * 前端任务构建管理grunt(gruntfile.js)\n  * 后端依赖管理maven(pom.xml)\n  * 后端任务构建管理gradle等。\n\n7. **CVS日志找某个特性的开发人**\n\n8. **Intellij的全文搜索**\n  全文搜索其实还是有一些技巧，根据前面采集到的一些有标志性的信息来进行搜索，今天看到子建还可以用`>Policy Holders<`这样的方式来搜索一个HTML标签等。多观察多学习。\n\n9. **网上资源库，一些可能有集中的相关context的人分享的平台，比如confluence**\n\n10. **前端UI/JavaScript相关可以在控制台Google Developer Tools中直接像素级调整/观察资源加载/调试等**\n  前端是个有趣且发挥想象力的地方，页面上的东西都是所见即所得，工作方式比较粗暴，要什么样式先直接在GDT里面调，像素级别地加减。\n\n## 慢即是快\n\n那么最后，与直接定位到问题所在的思维/解决方式不同的另外一种方式，是直接走通整个流程。这种方式通常更为可视化，理解更为透彻，也更花时间。但在尝试了所有能快速解决的方式仍不能成功的情况下，不能说这种方式就是慢。意在解决问题，而困难问题的解决，偏是需要耐心和智慧的。棋道术语曰“后中先”。常用的方法有：\n\n1. **经典的debug功能**\n\n2. **直接把整个程序跑起来**  \n  比如在做Java反射的时候，最为直观的方式就是把虚拟机build起来。\n\n## 查找一切 Google Everything \n好的，如果上面的方法依然不足以找到你需要的东西怎么办呢？把上面搜到的东西作为关键词，再采用其他的方式（如google）来进行链式搜索。Google乃是泛指，只要能搜到，管你是用什么工具（谢谢AlphaGo狗哥）。唯快不破，粗暴之美。\n\n## 总结与反省 Conclusion\n\n其实在快这个问题上，不妨认为“快”也只是其中的一种方式，不应拘束在术中，发现了好的方法能够提高效率，都该使用。另外，对为什么“快”的认知在学习的过程很重要，需要认清所需。不是一味追求快，以至对有时停步的思考都感到焦急。\n\n本篇侧重在技术的编码上，在其他方面还有很多习惯可以使我们的工作变得更快，比如：\n\n* 提高手速\n* 熟悉快捷键\n* 善用英文和搜索引擎\n* 使用markdown写作\n* 专注时间\n* 趁手的编辑器（sublime/vim/emacs等）/软件（Alfred/……没了）等\n\n对于工具这个专题，我 [自己也在写一些总结，托管在Gitbook上](https://www.gitbook.com/book/linesh/gitbook-elegant-mac-tools-system-closure/details)，尚未写完持续更新中，有兴趣的读者可以过来参阅。\n\n\n\n"},{"id":"2016-06-23-spring-mvc-documentation-reference","title":"Spring MVC官方文档翻译稿","contents":"\n\n这份是官方声明，哈哈哈。官方声明呢，可以给点bouns，就在这里说些最近的情况和其他的话。以下内容仅[star](https://github.com/linesh-simplicity/translation-spring-mvc-4-documentation)后可见。\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/spring-mvc-documentation-translation-project-snapshot.png)\n\n这个翻译项目从2015年9月份最早开始，中间停产了3个月，端端续续更新了1个月后，中间又停产了3个月左右，后来不知道为什么，又产生了坚持下去的偏执。所以最主要的部分都是半个月前翻出来的。这样的作息严格来说其实不太健康，不过最近一段时间在技术学习选择上出现了一点小迷惘，因此没事给自己找事情做，我觉得也无可厚非。\n\n入职11个月~~我真的没有在数日子~~，感觉上是进入了一个舒适区，项目、技术，和反馈。这个译本初稿的完成，其实也是我想对这段时间做个告别，重新出发。它会进入维护阶段，每天有规律的一点时间来维护，除此以外，接下来有一些的事要继续做：\n\n* **速度和基本功**。主要是规律、刻意地练习打字、快捷键、TDD、code kata。熊叔叔说的好，这些东西内化成下意识，才能更高效地思考其他\n* **professionalism**。项目上，作为ThoughtWorks developer的专业，要继续修炼\n\n以上。\n"},{"id":"2016-06-26-auto-deploy-translation-to-production-using-jenkins-and-qiniu","title":"使用Jenkins和七牛云自动化翻译文档发布流程","contents":"\n\n由gitbook迁移到七牛。其实就是将gitbook生成的静态站点`_book`文件夹拷贝到七牛的空间里，然后使用`index.html`作为入口。其中，主要就是两步工作：\n\n1. 确保使用正确的gitbook和gitbook-cli版本进行`gitbook build`构建，生成`_book`目录：\n  * 使用npm引入最新的gitbook和gitbook-cli：`npm install gitbook gitbook-cli --save`\n  * 在`book.json`中指定要使用的gitbook版本：` \"gitbook\": \">=3.1.0\" `\n2. 将生成的`_book`目录同步到七牛云。七牛提供了相应的开发者工具，只需要调用其API即可：`./qrsync ./conf.json`\n\n其中第二步，最容易想到的就是利用`git hook`的方式，在提交前调用七牛的API接口。但这个过程可能需要持续3~5分钟，这是我等不起的，这会让我尽量避免去push，进而使得我无法频繁提交。并且，提交就是提交，构建过程并不是我所需要关心的，也不需要让它占用我的时间。那么，很自然地想到， **是否能将这个过程放到远端来执行呢？**\n\n这不就是CI的作用嘛！想到这里，马上安装一个Jenkins撸起\n\n* 安装Jenkins\n* 新建一个free-style的项目\n* 配置git仓库地址、配置credential、配置Poll SCM\n* 安装Hudson Post Build插件：用于在构建完成后、七牛同步前执行一些脚本\n* 安装七牛云-jenkins插件：用于完成目录到七牛的自动同步\n* 注册一个七牛云开发者账号（如果要自定义域名，必须实名认证~~简直是坑~~并且账户里10元以上人民币）\n* 写点脚本\n\n## Ant Glob Pattern\n\n先上最后的成果图：\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/mvc-translation-with-new-domain-hosted-in-qiniu.png)\n\n![](http://7xqu8w.com1.z0.glb.clouddn.com/jenkins-pipeline-final-success.png)\n"}]