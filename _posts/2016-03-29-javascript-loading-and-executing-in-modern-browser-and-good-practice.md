---
layout: post
title: 模块化工程前夜——JavaScript在浏览器的加载执行、库与实践
---

讨论这个的前件：在前端工程化的子话题——模块化中，模块化架构对模块管理、请求合并、按需加载几个子问题有着非常重要的意义。在此前，我们需要了解

三个疑问：

* 如何做到并行下载顺序执行？
* 如何保证一段js代码依赖的所有文件在其执行前都被执行完毕？（呃……不就是顺序执行的问题嘛。有个前提是需要程序员自己去指定加载顺序，能否由框架自动去处理这个事情呢？）
* 若有多个脚本，只有其中一部分被声明为`async`，此时会触发document的渲染吗？看了一下，并不会，但有些操作DOM的代码却可以工作了，是不是暗示着，async的脚本会在DOM加载完再被执行

## JavaScript代码的声明方式

主要有两种：

* `<script>`标签中直接写入
* 通过`<script>`标签引入外部文件。外部文件来源又可能为：
   * 本地文件
   * 须由网络节点下载

## 浏览器端JavaScript代码的生命周期

JavaScript代码在浏览器端的执行一般要经历三个阶段：加载、执行、等待事件，其中前两个阶段在 [JavaScript权威指南（第6版）]()中被统称脚本执行阶段、后面一个阶段统称事件处理阶段。

### 加载和执行

对于来源不同的js代码/文件，加载过程意味着：

* 在`<script>`标签中直接写入的js代码：加载意味着把代码读取进来（可能读到内存【废话】中，也可能到执行引擎中，这里的说法不是特别严谨，但从概念模型上就是这么理解，实现细节与术语还得看规范和浏览器实现）
* 在`<script>`标签中引入的本地js文件：加载意味着把js代码下载并读取进来
* 在`<script>`标签中引入的网络js文件：加载意味着把js代码下载并读取进来

**理论模型上**，加载和执行是同步阻塞的。即默认情况下，解析引擎会先去加载脚本，加载完毕以后马上执行。只有执行完一段脚本后，才能开始对下一段脚本的加载和执行，这个过程是按照脚本之间定义的顺序串行执行的。

**在理论模型上**，浏览器会先尝试下载和渲染样式（css文件等），因为js可能会引用到最新的样式（比如`var width = $('#chatBox').width()`。而DOM树的渲染则会被阻塞到所有js加载完成后，因为js可能操作DOM（写入节点，删除节点等）从而动态更新其内容，因此此时去渲染DOM树是没有意义的。

### 并行下载（浏览器的Prefetch）

由于javascript文件的加载和执行是同步且阻塞的，对于大量或体积大的js文件，加载执行起来可能占用很长时间，影响DOM树的渲染速度。因此，现代浏览器一般都能完成智能优化，开启多个线程尽快地并行下载资源文件。这与是否标注了`defer`或`async`标志关系不大，更多是浏览器自身的优化行为。【如何证明？】

# 浏览器端js与DOM的互动

**在这个过程中，HTML的文档渲染是被阻塞的**。因为解析引擎不知道正在执行的JavaScript代码是否会改变操作DOM树，删除某些标签等，因此它不会尝试提前加载资源(css/img)等。

当然，“HTML的文档渲染被阻塞”仅仅意味着它在浏览器中不会被显示出来，而未暗示此时DOM树的加载情况（是尚未解析、还是已解析完存在于内存中，仅仅是还未被浏览器渲染）。

又当然，以上均是规范情况，浏览器通常会采取各自的优化形式。比如我在chrome上试了下，脚本都是同时开始下载的。

## `defer`和`async`

鉴于